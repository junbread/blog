[{"content":"아이템 69: 예외는 진짜 예외 상황에만 사용하라 예외는 오직 예외 상황에서만 쓰여야 하며, 일상적인 제어 흐름용으로 사용되어서는 안 된다.\n예외 코드를 사용하면 JVM에서 최적화할 수 있는 여지가 적어진다.\ntry { int i = 0; while(true) range[i++].climb(); } catch (ArrayIndexOutOfBoundsException e) {} // don\u0026#39;t for (Mountain m : range) m.climb(); // do 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없어야 한다.\n특정 상태에서만 호출할 수 있는 상태 의존적 메서드를 제공한다면, 상태 검사 메서드도 함께 제공해야 한다. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특수값(null 등)을 사용한다. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널/특수값을 사용한다. 아이템 70: 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라 자바에는 클라이언트가 무조건 처리해야 하는 검사 예외(checked exception), 처리하지 않아도 되는 비검사 예외(unchecked exception)이 있다.\n예외 사용법 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라. 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자. 확실하지 않다면 비검사 예외를 사용하자. Error는 관습적으로 복구 불가능하고 JVM이 더이상 프로그램을 실행할 수 없을 경우를 나타낸다. Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들면 안 된다. 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자. 아이템 71: 필요 없는 검사 예외 사용은 피하라 꼭 필요한 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 사용하기 힘든 API가 만들어진다.\n예외 상황에서 복구가 불가능하다면 비검사 예외를 던지자.\n검사 예외를 회피하는 방법 옵셔널을 반환한다. 부가 정보를 제공할 수 없지만 간단하게 처리할 수 있다. 검사 예외를 던지는 메서드를 2개로 쪼개어, 객체의 상태를 검사하는 메서드를 분리한다. 여러 스레드가 동시에 접근하는 상황에서는 적합하지 않다. 옵셔널만으로는 상황 처리에 충분하지 않을 경우에만 검사 예외를 던지자.\n아이템 72: 표준 예외를 사용하라 널리 사용되는 표준 예외를 재사용하면 여러 장점이 있다.\nAPI를 다른 사람이 사용하기 쉬워진다. API를 사용한 프로그램도 읽기 쉬워진다. 예외 클래스가 적을수록 메모리 사용량도 줄고, 클래스 적재 시간도 감소한다. 대표적인 표준 예외들 IllegalArgumentException\nIllegalStateException\nNullPointerException\nIndexOutOfBoundsException\nConcurrentModificationException\nUnsupportedOperationException\n유의사항 Exception, RuntimeException, Throwable, Error는 여러 예외를 포괄하는 일종의 추상 클래스 역할을 하므로, 직접 던지지 말자.\n아이템 73: 추상화 수준에 맞는 예외를 던지라 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하자. try { // 저수준 추상화를 이용한다. } catch (LowerLevelException e) { // 추상화 수준에 맞게 번역한다. throw new HigherLevelException(...); } 저수준 예외를 고수준 예외에 실어 보내는 예외 연쇄를 사용하면 유용하다.\n아이템 74: 메서드가 던지는 모든 예외를 문서화하라 메서드가 던지는 예외는 메서드를 올바로 사용하는 데 중요한 정보이기 때문에 문서화해야 한다.\n검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용해 정확히 문서화하자.\n비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.\n자바독에서는 메서드 선언의 throws에 등장하고 @throws에도 명시한 예외를 시각적으로 구분해주기 때문 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 클래스 설명에 일괄적으로 추가할 수도 있다.\n아이템 75: 예외의 상세 메시지에 실패 관련 정보를 담으라 예외 메시지를 남기는 이유는 실패 원인을 추적하기 위해서이다.\n따라서 예외가 발생할 때는 실패 메시지에 예외에 관여한 모든 매개변수와 필드의 값을 담아야 한다.\n단, 모든 정보를 담으려고 하거나 보안과 관련되어 있는 중요 정보까지 담을 필요는 없다.\n아이템 76: 가능한 한 실패 원자적으로 만들라 호출한 메서드가 실패하더라도 해당 객체는 호출 전 상태를 유지하는 것을 실패 원자성이라고 한다.\n실패 원자적으로 만드는 방법 불변 객체로 설계한다. 작업을 수행하기 전에 매개변수의 유효성을 검사한다. 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치한다. 객체의 임시 복사본에서 작업을 수행한 후에 성공적으로 완료되면 원래 객체와 교체한다. 작업 도중에 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌린다. 실패 원자성은 항상 보장할 수 있는 것은 아니므로, 비용을 고려해 판단해야 한다.\n메서드 명세에 기술한 예외라면 가급적 예외가 발생하더라도 객체의 상태는 변하지 않아야 하고, 상태가 변한다면 API 주석에 해당 사항을 명시해야 한다.\n아이템 77: 예외를 무시하지 말라 예외가 선언된 API는 해당 예외가 발생했을 때 조치를 취해야 한다.\ntry catch문으로 예외를 잡아놓고, 아무 조치를 취하지 않으면 안 된다.\n불가피하게 예외를 무시하기로 했다면, 예외 변수의 이름을 변경하고 무시하기로 한 이유를 주석으로 남기자.\n","permalink":"https://junbread.win/posts/2021/effective-java-10/","summary":"아이템 69: 예외는 진짜 예외 상황에만 사용하라 예외는 오직 예외 상황에서만 쓰여야 하며, 일상적인 제어 흐름용으로 사용되어서는 안 된다.\n예외 코드를 사용하면 JVM에서 최적화할 수 있는 여지가 적어진다.\ntry { int i = 0; while(true) range[i++].climb(); } catch (ArrayIndexOutOfBoundsException e) {} // don\u0026#39;t for (Mountain m : range) m.climb(); // do 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없어야 한다.\n특정 상태에서만 호출할 수 있는 상태 의존적 메서드를 제공한다면, 상태 검사 메서드도 함께 제공해야 한다.","title":"이펙티브 자바 10장 정리"},{"content":"아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.\n// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다. 컴파일러 최적화 수행 결과 의도하지 않은 대로 동작할 수도 있다. 멀티 스레드 환경에서 가변 공유 데이터를 다루는 방법 멀티스레드에서 가변 데이터를 공유하지 말자. (최선) → synchronized 를 사용해 동기화하자.\n동기화 시에는 읽기와 쓰기 모두를 동기화해야 한다.\nprivate static boolean stopRequested; private static synchronized void requestStop() { stopRequested = true; } private static synchronized boolean stopRequested() { return stopRequested; } → volatile 을 사용하면 항상 가장 최근에 기록된 값을 읽도록 보증한다. (메모리 접근)\nprivate static volatile boolean stopRequested; 하지만 원자적이지 않은 연산 수행 시에는 동기화해야 하며, 하지 않을 경우 안전 실패가 발생할 가능성이 있다. → java.util.concurrent에서 제공하는 Atomic* 자료구조를 사용하면, 동기화 락 없이도 스레드 안전하게 구현이 가능하다.\n아이템 79: 과도한 동기화는 피하라 너무 과한 동기화는 성능을 떨어뜨리고 데드락을 유발하거나, 안전 실패의 원인이 된다.\n응답 불가나 안전 실패를 피하려면 동기화 메서드나 동기화 블럭 안에서는 제어를 클라이언트에 양도해서는 안된다.\n외계인(?) 메서드\n// 코드 79-1 잘못된 코드. 동기화 블록 안에서 외계인 메서드를 호출한다. (420쪽) private final List\u0026lt;SetObserver\u0026lt;E\u0026gt;\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); public void addObserver(SetObserver\u0026lt;E\u0026gt; observer) { synchronized(observers) { observers.add(observer); } } public boolean removeObserver(SetObserver\u0026lt;E\u0026gt; observer) { synchronized(observers) { return observers.remove(observer); } } private void notifyElementAdded(E element) { synchronized(observers) { for (SetObserver\u0026lt;E\u0026gt; observer : observers) observer.added(this, element); } } ... public class Test2 { public static void main(String[] args) { ObservableSet\u0026lt;Integer\u0026gt; set = new ObservableSet\u0026lt;\u0026gt;(new HashSet\u0026lt;\u0026gt;()); set.addObserver(new SetObserver\u0026lt;\u0026gt;() { public void added(ObservableSet\u0026lt;Integer\u0026gt; s, Integer e) { System.out.println(e); if (e == 23) // 값이 23이면 자신을 구독해지한다. s.removeObserver(this); } }); for (int i = 0; i \u0026lt; 100; i++) set.add(i); } } 테스트 실행 시 ConcurrentModificationException 발생!\n→ 동기화 블럭 안에서 클라이언트 메서드가 호출되었기 때문에 synchronized의 보호를 받지 못한다.\n// 코드 79-3 외계인 메서드를 동기화 블록 바깥으로 옮겼다. - 열린 호출 (424쪽) private void notifyElementAdded(E element) { List\u0026lt;SetObserver\u0026lt;E\u0026gt;\u0026gt; snapshot = null; synchronized(observers) { snapshot = new ArrayList\u0026lt;\u0026gt;(observers); } for (SetObserver\u0026lt;E\u0026gt; observer : snapshot) observer.added(this, element); } // 코드 79-4 CopyOnWriteArrayList를 사용해 구현한 스레드 안전하고 관찰 가능한 집합 (425쪽) private final List\u0026lt;SetObserver\u0026lt;E\u0026gt;\u0026gt; observers = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); public void addObserver(SetObserver\u0026lt;E\u0026gt; observer) { observers.add(observer); } public boolean removeObserver(SetObserver\u0026lt;E\u0026gt; observer) { return observers.remove(observer); } private void notifyElementAdded(E element) { for (SetObserver\u0026lt;E\u0026gt; observer : observers) observer.added(this, element); } @Override public boolean add(E element) { boolean added = super.add(element); if (added) notifyElementAdded(element); return added; } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { boolean result = false; for (E element : c) result |= add(element); // notifyElementAdded를 호출한다. return result; } 동기화 영역은 최대한 작게 가져가자.\n합당한 이유가 있을 때만 내부에서 동기화하고, 동기화 여부를 문서에 명확히 밝히자.\n아이템 80: 스레드보다는 실행자, 태스크, 스트림을 애용하라 작업 큐를 만들기 위해 스레드를 직접 다루기보다는 java.util.concurrent 하위의 실행자 프레임워크를 이용하자.\nExecutorService exec = Executors.newSingleThreadExecutor(); exec.execute(runnable); exec.shutdown(); 실행자 프레임워크의 기능 특정 태스크 완료 대기 태스크 모음 중 아무거나 하나, 혹은 모든 태스크 완료 대기 실행자 서비스 종료 대기 완료된 태스크의 결과를 차례로 받기 태스크를 특정 시간, 혹은 주기로 실행하기 프로그램 규모에 따라 각각 다른 스레드 관리 메커니즘을 사용하는 실행자 서비스를 생성할 수 있다.\nex) Executors.newCachedThreadPool, Executors.newFixedThreadPool, \u0026hellip;\n자바 7부터는 ForkJoinPool을 지원하도록 개량되어서 효율성이 개선되었다.\n아이템 81: wait과 notify보다는 동시성 유틸리티를 애용하라 wait과 notify는 올바르게 사용하기 매우 어려우므로, 고수준 동시성 유틸리티를 사용하는 것이 좋다.\n고수준 동시성 유틸리티의 종류 실행자 프레임워크 동시성 컬렉션 ConcurrentHashMap 등 내부에서 동기화를 효율적으로 구현한 컬렉션 상태 의존적 메서드들이 추가되어 있음 ex) putIfAbsent 동기화 장치 CountDownLatch, Semaphore, \u0026hellip; // 코드 81-3 동시 실행 시간을 재는 간단한 프레임워크 (433-434쪽) public class ConcurrentTimer { private ConcurrentTimer() { } // 인스턴스 생성 불가 public static long time(Executor executor, int concurrency, Runnable action) throws InterruptedException { CountDownLatch ready = new CountDownLatch(concurrency); CountDownLatch start = new CountDownLatch(1); CountDownLatch done = new CountDownLatch(concurrency); for (int i = 0; i \u0026lt; concurrency; i++) { executor.execute(() -\u0026gt; { ready.countDown(); // 타이머에게 준비를 마쳤음을 알린다. try { start.await(); // 모든 작업자 스레드가 준비될 때까지 기다린다. action.run(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { done.countDown(); // 타이머에게 작업을 마쳤음을 알린다. } }); } ready.await(); // 모든 작업자가 준비될 때까지 기다린다. long startNanos = System.nanoTime(); start.countDown(); // 작업자들을 깨운다. done.await(); // 모든 작업자가 일을 끝마치기를 기다린다. return System.nanoTime() - startNanos; } } 어쩔 수 없이 wait/notify를 사용해야 할 때에는 wait 호출 시 while 문 안에서만 호출하는 표준 방식을 따르자.\nsynchronized (obj) { while (\u0026lt;조건이 충족되지 않았다\u0026gt;) obj.wait(); // (락을 놓고, 깨어나면 다시 잡는다.) ... // 조건이 충족됐을 때의 동작을 수행한다. } 아이템 82: 스레드 안전성 수준을 문서화하라 멀티스레드 환경에서 API를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 명시해야 한다.\\\n스레드 안전성 수준 불변 무조건적 스레드 안전: 수정될 수 있으나 내부에서 동기화해서 별도의 처리 없이 스레드 안전하게 사용 가능하다. 조건부 스레드 안전: 일부 스레드를 사용하려면 외부 동기화가 필요하다. 스레드 안전하지 않음: 동시에 사용하기 위해서는 외부 동기화가 필요하다. 스레드 적대적: 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다. (정적 데이터를 동기화 없이 수정하는 경우) 조건부 스레드 안전한 클래스는 주의해서 어떤 순서로 호출할 때 동기화 로직이 필요한지, 어떤 락을 얻어야 하는지 기술해야 한다.\n공개된 락을 사용하는 경우 클라이언트에서 락을 풀지 않는 서비스 거부 공격을 할 수 있기 때문에, 비공개 락 객체를 사용하고 final로 선언하는 것이 좋다.\n아이템 83: 지연 초기화는 신중히 사용하라 상황에 따라 지연 초기화는 오히려 성능을 더 느리게 만들 수 있으므로 신중히 사용해야 한다.\n대부분의 상황에서는 일반적인 초기화가 좋다.\n멀티스레드 환경에서의 지연 초기화 지연 초기화가 초기화 순환성을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자.\n// 코드 83-2 인스턴스 필드의 지연 초기화 - synchronized 접근자 방식 (443쪽) private FieldType field2; private synchronized FieldType getField2() { if (field2 == null) field2 = computeFieldValue(); return field2; } 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.\n// 코드 83-3 정적 필드용 지연 초기화 홀더 클래스 관용구 (443쪽) private static class FieldHolder { static final FieldType field = computeFieldValue(); } private static FieldType getField() { return FieldHolder.field; } 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중 검사 관용구를 사용하자.\n→ 이미 초기화된 경우 synchronized 블럭에 진입하지 않아서 접근 비용이 작아진다.\n// 코드 83-4 인스턴스 필드 지연 초기화용 이중검사 관용구 (444쪽) private volatile FieldType field4; private FieldType getField4() { FieldType result = field4; if (result != null) // 첫 번째 검사 (락 사용 안 함) return result; synchronized(this) { if (field4 == null) // 두 번째 검사 (락 사용) field4 = computeFieldValue(); return field4; } } 반복해서 초기화해도 상관없는 경우 동기화 없이 단일 검사해도 괜찮다.\n아이템 84: 프로그램의 동작을 스레드 스케줄러에 기대지 말라 스레드 스케줄러의 동작은 플랫폼, 운영체제마다 다르기 때문에 다른 플랫폼에 이식하기 어려워질 수 있다.\n실행 가능한 스레드의 수가 프로세스의 수보다 과도하게 많아서는 안 된다.\n스레드는 당장 처리해야 할 작업이 없다면 실행되어서는 안 된다.\n스레드는 절대 바쁜 대기 상태가 되어서는 안 된다.\n// 코드 84-1 끔찍한 CountDownLatch 구현 - 바쁜 대기 버전! (447쪽) public class SlowCountDownLatch { private int count; public SlowCountDownLatch(int count) { if (count \u0026lt; 0) throw new IllegalArgumentException(count + \u0026#34; \u0026lt; 0\u0026#34;); this.count = count; } public void await() { while (true) { synchronized(this) { if (count == 0) return; } } } public synchronized void countDown() { if (count != 0) count--; } → 이 문제를 고친답시고 Thread.yield 등을 사용한다면 JVM 구현체별로 다른 효과에 이식성만 나빠지는 결과를 초래할 수 있다.\n","permalink":"https://junbread.win/posts/2021/effective-java-11/","summary":"아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.\n// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다.","title":"이펙티브 자바 11장 정리"},{"content":"아이템 85: 자바 직렬화의 대안을 찾으라 자바 직렬화에는 공격의 소지가 매우 많고, 점점 더 많아지고 있기 때문에 가급적 사용하지 말아야 한다.\n자바 직렬화를 사용하는 방법 아무것도 역직렬화하지 않는다.\n레거시 등으로 어쩔 수 없이 사용하더라도, 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는다.\n아이템 86: Serializable을 구현할지는 신중히 결정하라 Serializable 구현의 단점들 Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.\n→ 직렬화 형태 또한 공개 API가 되기 때문\n버그와 보안 구멍이 생길 가능성이 높아진다.\n해당 클래스의 신버전을 릴리즈할 때 테스트해야 할 것이 늘어난다.\nSerializable 구현하면 안 되는 경우 상속용으로 설계된 클래스는 Serializable을 구현해서는 안 되고, 인터페이스도 Serializable을 확장해서는 안 된다.\n→ 불가피하게 상속 가능 serializable을 구현해야 한다면, finalize 메서드를 재정의하지 못하도록 하자.\n내부 클래스는 직렬화를 구현하지 말아야 한다.\n→ 바깥 인스턴스 참조와 유효 지역변수 값을 저장하기 위해 컴파일러가 임의로 생성한 필드가 들어가기 때문에 직렬화 형태가 일관적이지 않다.\n아이템 87: 커스텀 직렬화 형태를 고려해보라 객체의 물리적 표현과 논리적 표현이 같다면 기본 직렬화 형태를 유지해도 괜찮지만, 그렇지 않다면 커스텀 직렬화 형태를 고려하자.\n기본 직렬화 형태에 적합한 클래스 public class Name implements Serializable { /** * 성. null이 아니어야 한다. * @serial */ private final Stirng lastName; /** * 이름. null이 아니어야 한다. * @serial */ private final String firstName; /** * 중간이름. 중간이름이 없다면 null * @serial */ private final String middleName; ... // 나머지 코드는 생략 } 기본 직렬화 형태에 적합하지 않은 클래스 public final class StringList implements Serializable { private int size = 0; private Entry head = null; private static class Entry implements Serializable { String data; Entry next; Entry previous; } } 기본 직렬화 형태로 직렬화 시에 양방향 연결 노드를 모두 직렬화하게 된다.\n공개 api가 현재의 내부 표현 방식에 영구히 묶인다. 너무 많은 공간을 차지할 수 있다. 시간이 너무 많이 걸릴 수 있다. 스택 오버플로를 일으킬 수 있다. 직렬화 시에 고려해야 할 것들 transient 한정자가 붙은 인스턴스 필드는 직렬화되지 않는다. 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient를 생략하자. 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다. 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하고, 전 버전과의 호환성을 끊으려는 경우를 제외하고는 수정하지 말자. 아이템 88: readObject 메서드는 방어적으로 작성하라 역직렬화 메서드 readObject는 또 다른 public 생성자이기 때문에 불변식을 훼손하지 않도록 방어적으로 작성해야 한다.\n객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 가지는 필드를 모두 방어적으로 복사해야 한다.\n안전한 readObject 메서드를 작성하는 법 private이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하자. 모든 불변식을 검사하여 어긋나는 것이 발견되면 InvalidObjectException을 던지자. 방어적 복사 이후에 불변식 검사가 뒤따라야 한다. 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하자. 직접적이든 간접적이든 재정의할 수 있는 메서드는 호출하면 안 된다. 아이템 89: 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라 싱글턴 클래스는 Serializable을 구현하게 될 경우 인스턴스가 하나임을 보장할 수 없게 된다. 이때 readResolve 메서드를 사용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다. 만약 싱글턴 클래스가 transient로 선언하지 않은 참조 타입 인스턴스 필드를 가지고 있다면, 역직렬화 과정에서 원본 객체가 아닌 인스턴스를 가져올 수 있다. 인스턴스 수를 통제하기 위한 방법들 컴파일 타임에 인스턴스 필드 값의 종류를 모두 알 수 있다면 자바 언어 자체적으로 인스턴스가 하나임을 보장하는 enum을 사용하자. 불가피한 경우에만 readResolve 메서드를 사용하자. 모든 참조 타입 인스턴스 필드를 transient로 선언해야 한다. 상속 가능한 클래스의 경우 readResolve 메서드의 접근자에 주의하자. protected/public이면서 하위 클래스에서 재정의하지 않았으면, 하위 클래스의 역직렬화시 상위 클래스의 인스턴스가 생성될 수 있다. 아이템 90: 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라 제 3자가 확장할 수 없는 클래스라면 가능한 한 직렬화 프록시 패턴을 사용하자.\n직렬화 프록시 패턴 구현하기 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 private static으로 선언한다. 바깥 클래스를 매개변수로 받는 중첩 클래스의 유일한 생성자를 선언한다. 바깥 클래스, 직렬화 프록시 모두 Serializable을 구현한다고 선언한다. 직렬화 프록시에 readResolve() 메서드를 구현하고, 바깥 클래스에 writeReplace()를 선언한다. class Period implements Serializable { private final Date start; private final Date end; public Period(Date start, Date end) { this.start = start; this.end = end; } private static class SerializationProxy implements Serializable { private static final long serialVersionUID = 2123123123; private final Date start; private final Date end; public SerializationProxy(Period p) { this.start = p.start; this.end = p.end; } private Object readResolve() { return new Period(start, end); } } private Object writeReplace() { return new SerializationProxy(this); } private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException(\u0026#34;프록시가 필요합니다.\u0026#34;); } } 직렬화 프록시 패턴의 한계 확장 가능한 클래스에는 적용할 수 없다. 객체 그래프에 순환이 있는 경우에는 적용할 수 없다. 방어적 복사하는 경우보다 속도가 느리다. ","permalink":"https://junbread.win/posts/2021/effective-java-12/","summary":"아이템 85: 자바 직렬화의 대안을 찾으라 자바 직렬화에는 공격의 소지가 매우 많고, 점점 더 많아지고 있기 때문에 가급적 사용하지 말아야 한다.\n자바 직렬화를 사용하는 방법 아무것도 역직렬화하지 않는다.\n레거시 등으로 어쩔 수 없이 사용하더라도, 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는다.\n아이템 86: Serializable을 구현할지는 신중히 결정하라 Serializable 구현의 단점들 Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.\n→ 직렬화 형태 또한 공개 API가 되기 때문\n버그와 보안 구멍이 생길 가능성이 높아진다.","title":"이펙티브 자바 12장 정리"},{"content":"아이템 49: 매개변수가 유효한지 검사하라 메서드나 생성자를 작성할 때에는 매개변수에 어떤 제약이 있을지 생각해야 한다.\n제약사항을 문서화하고 메서드 시작 부분에 명시적으로 검사하자. 유효성 검사를 제대로 하지 않는 경우에는 중간에 모호한 오류가 발생하거나, 잘못된 결과를 반환하거나, 실패 원자성이 깨지는 결과를 낳을 수 있다. public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. /** * (현재 값 mod m) 값을 반환한다. 이 메서드는 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다. * * @param m 계수(양수여야 한다.) * @return 현재 값 mod m * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다. */ public BigInteger mod(BigInteger m) { if (m.signum() \u0026lt;= 0) throw new ArithmeticException(\u0026#34;계수(m)는 양수여야 합니다. \u0026#34; + m); ... // 계산 수행 } 자바 7부터는 Objects.requireNonNull 메서드 등을 사용하면 null 검사를 편하게 할 수 있다.\nthis.strategy = Objects.requireNonNull(strategy, \u0026#34;전략\u0026#34;); 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써야 한다.\n→ 저장 시점에 오류가 발생하지 않기 때문\n메서드 몸체 실행 전 매개변수 유효성 검사의 예외 유효성 검사 비용이 지나치게 높은 경우 계산 과정에서 암묵적으로 유효성 검사가 실행되는 경우 메서드 수행 중 API에서 던지기로 한 예외와 다른 예외가 발생하는 경우 API에서 던지기로 한 예외로 번역해주어야 한다. 아이템 50: 적시에 방어적 복사본을 만들라 클래스가 클라이언트로부터 받는 매개변수가 가변 객체인 경우 방어적 복사를 통해 클래스 내부를 보호해야 한다.\n가변 클래스인 java.lang.Date를 매개변수로 받는 Period 클래스 // 코드 50-1 기간을 표현하는 클래스 - 불변식을 지키지 못했다. (302-305쪽) public final class Period { private final Date start; private final Date end; /** * @param start 시작 시각 * @param end 종료 시각. 시작 시각보다 뒤여야 한다. * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다. * @throws NullPointerException start나 end가 null이면 발생한다. */ public Period(Date start, Date end) { if (start.compareTo(end) \u0026gt; 0) throw new IllegalArgumentException( start + \u0026#34;가 \u0026#34; + end + \u0026#34;보다 늦다.\u0026#34;); this.start = start; this.end = end; } public Date start() { return start; } public Date end() { return end; } public String toString() { return start + \u0026#34; - \u0026#34; + end; } } 가변 매개변수를 이용한 공격 // 코드 50-2 Period 인스턴스의 내부를 공격해보자. (303쪽) Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); end.setYear(78); // p의 내부를 변경했다! System.out.println(p); 이와 같은 공격을 예방하려면 적시에 객체의 방어적 복사본을 만들어야 한다.\n→ 이때 clone 메서드는 final이 아닌 타입의 경우 재정의할 수 있기 때문에 사용해서는 안 된다.\n가변 반환값을 이용한 공격 // 코드 50-4 Period 인스턴스를 향한 두 번째 공격 (305쪽) start = new Date(); end = new Date(); p = new Period(start, end); p.end().setYear(78); // p의 내부를 변경했다! System.out.println(p); 이 경우에도 동일하게 가변 필드의 방어적 복사본을 만들어 반환하면 된다.\n→ 인스턴스 필드에 있는 객체의 타입은 보장되기 때문에 clone 메서드를 사용해도 관계없다. (하지만 굳이 사용하지는 말자)\n아이템 51: 메서드 시그니처를 신중히 설계하라 메서드 이름을 신중히 짓자. 항상 표준 명명 규칙을 따르고, 같은 패키지의 다른 이름들과 일관되게 짓자. 너무 긴 이름은 피하자. 편의 메서드를 너무 많이 만들지 말자. 매개변수 목록은 짧게 유지하자. 같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 최악이다. 매개변수 목록이 길 때 사용할 수 있는 방법 여러 메서드로 쪼개기 e.g. subList() and indexOf() 매개변수 여러 개를 묶어주는 헬퍼 클래스 만들기 e.g. XXXCriteria 빌더 패턴을 메서드 호출에 응용하기 매개변수 타입으로는 가능하다면 인터페이스를 사용하자. \u0026lsquo;진짜\u0026rsquo; boolean이 아닌 이상 boolean보다는 enum이 낫다. 아이템 52: 다중정의는 신중히 사용하라 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다. 어떤 다중정의한 메서드를 사용할지는 컴파일 타임에 정해진다. // 코드 52-1 컬렉션 분류기 - 오류! 이 프로그램은 무엇을 출력할까? (312쪽) public class CollectionClassifier { public static String classify(Set\u0026lt;?\u0026gt; s) { return \u0026#34;집합\u0026#34;; } public static String classify(List\u0026lt;?\u0026gt; lst) { return \u0026#34;리스트\u0026#34;; } public static String classify(Collection\u0026lt;?\u0026gt; c) { return \u0026#34;그 외\u0026#34;; } public static void main(String[] args) { Collection\u0026lt;?\u0026gt;[] collections = { new HashSet\u0026lt;String\u0026gt;(), new ArrayList\u0026lt;BigInteger\u0026gt;(), new HashMap\u0026lt;String, String\u0026gt;().values() }; for (Collection\u0026lt;?\u0026gt; c : collections) System.out.println(classify(c)); } } 다중정의가 혼동을 일으키는 상황을 피해야 한다. 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들면 안 된다. 다중정의하는 대신 메서드 이름을 다르게 지어줄 수도 있다. e.g. readBoolean(), readInt(), readLong(), \u0026hellip; 생성자의 경우에는 어쩔 수 없지만 정적 팩터리 메서드를 활용하는 방식도 있다. 메서드 다중정의 시 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다. 아이템 53: 가변인수는 신중히 사용하라 가변인수 사용 시 성능 문제에 주의하자.\n→ 가변인수 메서드는 호출될 때마다 배열을 생성하기 때문이다.\n인수가 n개 이상이어야 할 경우, n개까지는 직접 명시하고 이후부터 가변인수를 사용하자. 성능에 민감한 상황이라면, 호출 빈도를 고려해 자주 사용되는 인수 개수의 메서드는 다중정의해 놓자. 아이템 54: null이 아닌, 빈 컬렉션이나 배열을 반환하라 컬렉션이나 배열을 반환하도록 되어 있는 메서드의 경우 null을 반환하면 사용처에서 추가로 null 체크 로직이 추가되어야 해서 복잡도가 늘어난다.\n빈 컬렉션이나 배열을 반환하자. 성능 문제가 걱정된다면 캐시된 불변 객체를 반환하도록 만들 수도 있다. 아이템 55: 옵셔널 반환은 신중히 하라 자바 8부터 제공되는 옵셔널은 명시적으로 반환값이 없을 수도 있다고 선언하는 효과를 준다.\n옵셔널의 활용방법 기본값을 정해둔다. orElse(XXX) 기본값 설정비용이 큰 경우 미리 생성하지 않고 supplier 함수를 제공할 수도 있다. 원하는 예외를 던진다. orElseThrow() 항상 값이 채워져 있다고 가정한다. get() 옵셔널 사용 시 주의사항 옵셔널을 반환하도록 선언되어 있는 메서드는 절대 null을 반환해서는 안 된다. 컬렉션, 스트림, 배열, 옵셔널 등의 컨테이너 타입은 옵셔널로 감싸면 안 된다. 박싱된 기본 타입을 옵셔널로 감싸기보단, 전용 옵셔널 클래스를 사용하자. 옵셔널을 컬렉션의 키, 값, 원소로 사용하는 것은 부적절하다. 빈 값을 표현하는 방법이 두 가지가 되기 때문 아이템 56: 공개된 API 요소에는 항상 문서화 주석을 작성하라 문서화 주석의 원칙 API를 올바로 문서화하기 위해서는 모든 클래스와 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다. 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다. how가 아닌 what 호출을 위한 전제조건, 부작용 등 문서화 주석 태그\n문서화 주석 작성 주의사항 문서화 주석의 요약 설명은 반드시 대상의 기능을 고유하게 기술해야 한다. 한 클래스 안에서 요약 설명이 똑같은 멤버가 둘 이상이면 안 된다. 제네릭 타입이나 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다. 열거 타입을 문서화할 때는 상수에도 주석을 달아야 한다. 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다. 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 API 설명에 포함해야 한다. javadoc으로 생성된 문서 페이지를 직접 읽어보고 잘 작성된 문서화 페이지인지 점검하자.\n","permalink":"https://junbread.win/posts/2021/effective-java-08/","summary":"아이템 49: 매개변수가 유효한지 검사하라 메서드나 생성자를 작성할 때에는 매개변수에 어떤 제약이 있을지 생각해야 한다.\n제약사항을 문서화하고 메서드 시작 부분에 명시적으로 검사하자. 유효성 검사를 제대로 하지 않는 경우에는 중간에 모호한 오류가 발생하거나, 잘못된 결과를 반환하거나, 실패 원자성이 깨지는 결과를 낳을 수 있다. public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. /** * (현재 값 mod m) 값을 반환한다. 이 메서드는 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.","title":"이펙티브 자바 8장 정리"},{"content":"아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.\n지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다.\nIterator\u0026lt;Element\u0026gt; i = c.iterator(); while (i.hasNext()) { doSomething(i.next()); } for (Iterator\u0026lt;Element\u0026gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); doSomething(e); } 아이템 58: 전통적인 for 문보다는 for-each 문을 사용하라 자바 1.5부터 추가된 for-each 문은 전통적인 for 문보다 깔끔하고 예상치 못한 오류를 줄여 준다.\nIterable을 구현한 객체라면 무엇이든 순회 가능하다.\nvar list = new ArrayList\u0026lt;Integer\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) { } for (var item : list) { } for-each를 사용할 수 없는 상황 파괴적인 필터링: 컬렉션을 순회하면서 특정 원소를 제거\n자바 8부터는 Collections.removeIf()를 사용할 수 있다.\n변형: 컬렉션을 순회하면서 원소의 값 또는 전체를 교체\n병렬 반복: 컬렉션을 병렬로 순회\n아이템 59: 라이브러리를 익히고 사용하라 표준 라이브러리를 사용하면 코드를 작성한 전문가의 지식과 다른 프로그래머의 경험을 활용할 수 있다.\n→ 바퀴를 재발명하지 말자.\n아이템 60: 정확한 답이 필요하다면 float와 double은 피하라 float과 double 등의 부동 소수점 연산 타입은 정확한 값이 아닌 근사치를 사용하기 때문에, 정확한 값이 필요할 때는 사용하면 안 된다.\n→ 느리지만 정확한 값이 필요하다면 BigInteger, BigDecimal 타입을 사용하자.\n아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라 오토박싱이 지원되기 때문에 기본 타입과 참조 타입을 큰 구분없이 사용할 수 있지만, 사용에 주의해야 한다.\n기본 타입과 박싱된 기본 타입의 차이점 기본 타입은 값만 가지고 있지만, 박싱된 기본 타입은 참조 타입이기 때문에 참조 식별성이 있다.\nvar a = new Integer(1); var b = new Integer(1); a.equals(b); // true a == b; // false 박싱된 기본 타입은 null을 가질 수 있다.\n기본 타입이 박싱된 타입보다 효율적이다.\n박싱 타입은 참조 타입이기 때문에 무조건 메모리를 사용하지만, 기본 타입은 변수 자체에 값이 있다. 박싱된 타입 사용시 발생할 수 있는 상황들 박싱된 타입에서 동등성 비교를 equals() 대신 ==를 사용해서 하게 되면 정상적으로 동작하지 않는다.\n기본 타입과 박싱된 타입을 혼용한 연산에서는 대부분 언박싱되므로, NPE에 주의해야 한다.\npublic class Unbelievable { static Integer i; public static void main(String[] args) { if (i == 42) { System.out.println(\u0026#34;믿을 수 없군\u0026#34;); } } } 타입을 잘못 사용하게 되면 오토박싱으로 인한 성능 저하가 일어난다.\npublic static void main(String[] args) { Long sum = 0L; for (long i = 0L; i \u0026lt; Integer.MAX_VALUE; i++) { sum += i; } System.out.println(sum); } 매개변수화 타입의 타입 매개변수로 사용할 때, 리플렉션을 사용할 때를 제외하고는 기본 타입을 사용하는 것이 낫다.\n아이템 62: 다른 타입이 적절하다면 문자열 사용을 피하라 더 적절한 타입이 있거나 새로 작성할 수 있다면 문자열을 사용하지 말고 해당 타입을 사용하자.\n다른 값 타입/열거 타입/혼합 타입을 표현하기 위해 문자열을 사용하지 말아야 한다.\n아이템 63: 문자열 연결은 느리니 주의하라 문자열은 불변이기 때문에, 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 한다.\n→ 많은 문자열을 연결할 때는 문자열 연결 연산자(+) 대신 StringBuilder를 사용하자.\n아이템 64: 객체는 인터페이스를 사용해 참조하라 인터페이스를 참조하면 프로그램이 훨씬 유연해진다.\n적합한 인터페이스가 있는 경우 매개변수, 반환값, 변수, 필드 등 객체를 참조하는 모든 곳을 인터페이스 타입으로 선언하자. 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 상위 클래스를 타입으로 사용하자. 아이템 65: 리플렉션보다는 인터페이스를 사용하라 리플렉션은 강력하지만, 장황하고 오류를 만들기 쉽기 때문에 아주 제한된 형태로만 사용해야 한다.\n리플렉션으로 인스턴스를 생성하는 경우 인터페이스나 상위 클래스로 참조해 사용하는 것이 좋다.\n리플렉션의 단점 컴파일타임 타입 검사의 이점을 누릴 수 없다. 코드가 지저분하고 장황해진다. 성능이 떨어진다. // 리플렉션으로 활용한 인스턴스화 데모 public class ReflectiveInstantiation { // 코드 65-1 리플렉션으로 생성하고 인터페이스로 참조해 활용한다. (372-373쪽) public static void main(String[] args) { // 클래스 이름을 Class 객체로 변환 Class\u0026lt;? extends Set\u0026lt;String\u0026gt;\u0026gt; cl = null; try { cl = (Class\u0026lt;? extends Set\u0026lt;String\u0026gt;\u0026gt;) // 비검사 형변환! Class.forName(args[0]); } catch (ClassNotFoundException e) { fatalError(\u0026#34;클래스를 찾을 수 없습니다.\u0026#34;); } // 생성자를 얻는다. Constructor\u0026lt;? extends Set\u0026lt;String\u0026gt;\u0026gt; cons = null; try { cons = cl.getDeclaredConstructor(); } catch (NoSuchMethodException e) { fatalError(\u0026#34;매개변수 없는 생성자를 찾을 수 없습니다.\u0026#34;); } // 집합의 인스턴스를 만든다. Set\u0026lt;String\u0026gt; s = null; try { s = cons.newInstance(); } catch (IllegalAccessException e) { fatalError(\u0026#34;생성자에 접근할 수 없습니다.\u0026#34;); } catch (InstantiationException e) { fatalError(\u0026#34;클래스를 인스턴스화할 수 없습니다.\u0026#34;); } catch (InvocationTargetException e) { fatalError(\u0026#34;생성자가 예외를 던졌습니다: \u0026#34; + e.getCause()); } catch (ClassCastException e) { fatalError(\u0026#34;Set을 구현하지 않은 클래스입니다.\u0026#34;); } // 생성한 집합을 사용한다. s.addAll(Arrays.asList(args).subList(1, args.length)); System.out.println(s); } private static void fatalError(String msg) { System.err.println(msg); System.exit(1); } } 아이템 66: 네이티브 메서드는 신중히 사용하라 자바는 JNI를 통해 네이티브 코드에 접근할 수 있지만, 사용에 신중해야 한다.\n네이티브 메서드가 성능을 개선하는 일은 많지 않으며, 디버깅 용이성과 이식성을 저하시킨다. 네이티브 코드는 안전하지 않기 때문에 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않다. 아이템 67: 최적화는 신중히 하라 빠른 프로그램보다는 좋은 프로그램이 낫다. 성능을 제한하는 설계를 피하라. API를 설계할 때 성능에 주는 영향을 고려하라. 하지만 성능을 위해 API를 왜곡하면 안 된다. 최적화 시도 전후로 성능을 측정하자. 아이템 68: 일반적으로 통용되는 명명 규칙을 따르라 표준 명명 규칙을 습관화하자.\n","permalink":"https://junbread.win/posts/2021/effective-java-09/","summary":"아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.\n지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다.","title":"이펙티브 자바 9장 정리"},{"content":"아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.\nCollections.sort(words, new Comparator\u0026lt;String\u0026gt;() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.\nCollections.sort(words, (s1, s2) -\u0026gt; Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (\u0026#34;+\u0026#34;, (x, y) -\u0026gt; x + y), MINUS (\u0026#34;-\u0026#34;, (x, y) -\u0026gt; x - y), TIMES (\u0026#34;*\u0026#34;, (x, y) -\u0026gt; x * y), DIVIDE(\u0026#34;/\u0026#34;, (x, y) -\u0026gt; x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this.symbol = symbol; this.op = op; } @Override public String toString() { return symbol; } public double apply(double x, double y) { return op.applyAsDouble(x, y); } } 람다 사용시의 주의점 타입을 명시해야 코드가 더 명확해질 때를 제외하고는 람다의 모든 매개변수 타입을 생략하자. 람다는 이름이 없고 문서화도 못 하기 때문에, 코드 자체로 명확히 설명되지 않거나 코드 줄 수가 많아지면 사용을 삼가자. 구현체별로 직렬화 방식이 다를 수 있기 때문에, 람다를 직렬화해서는 안 된다. 람다를 사용할 수 없는 경우 추상 클래스의 인스턴스를 만드는 경우 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만드는 경우 this가 자기 자신을 가리켜야 하는 경우 아이템 43: 람다보다는 메소드 참조를 사용하라 메소드 참조를 사용하면 람다보다도 간결한 코드를 작성할 수 있다.\nfrequencyTable.merge(s, 1, (count, incr) -\u0026gt; count + incr); // 람다 frequencyTable.merge(s, 1, Integer::sum); // 메서드 참조 람다가 메서드 참조보다 더 간결한 경우도 있다. e.g. 람다와 메서드가 같은 클래스 내에 있을 경우\n메서드 참조 유형 정적\nstr -\u0026gt; Integer.parseInt(str) ⇒ Integer::parseInt 한정적 (인스턴스)\nInstant then = Instant.now(); t -\u0026gt; then.isAfter(t); Instant.now()::isAfter 비한정적 (인스턴스)\nstr -\u0026gt; str.toLowerCase() ⇒ String::toLowerCase 클래스 생성자\n() -\u0026gt; new TreeMap\u0026lt;K, V\u0026gt;() ⇒ TreeMap\u0026lt;K,V\u0026gt;::new 배열 생성자\nlen -\u0026gt; new int[len] ⇒ int[]::new 아이템 44: 표준 함수형 인터페이스를 사용하라 자바에서는 람다에 사용할 수 있도록 다양한 모양의 표준 함수형 인터페이스를 제공하고 있다.\n람다에 사용하기 위해 직접 인터페이스를 구현하기보다는, 표준 함수형 인터페이스를 사용하자. 전용 함수형 인터페이스를 구현해야 하는 경우 e.g. Comparator\n자주 쓰이며, 이름 자체가 용도를 명확히 설명한다. 반드시 따라야 하는 규약이 있다. 유용한 디폴트 메서드를 제공할 수 있다. 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자.\n아이템 45: 스트림은 주의해서 사용하라 자바 8에서 추가된 스트림은 다량의 데이터 처리 작업을 위해 도입되었다.\n스트림 파이프라인 스트림 파이프라인은 지연 평가된다. 평가는 종단 연산이 호출될 때 이루어지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다. 스트림을 잘못 사용하면 읽기 어렵고 유지보수가 힘든 코드가 만들어진다.\n// 코드 45-2 스트림을 과하게 사용했다. - 따라 하지 말 것! (270-271쪽) public class StreamAnagrams { public static void main(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); try (Stream\u0026lt;String\u0026gt; words = Files.lines(dictionary)) { words.collect( groupingBy(word -\u0026gt; word.chars().sorted() .collect(StringBuilder::new, (sb, c) -\u0026gt; sb.append((char) c), StringBuilder::append).toString())) .values().stream() .filter(group -\u0026gt; group.size() \u0026gt;= minGroupSize) .map(group -\u0026gt; group.size() + \u0026#34;: \u0026#34; + group) .forEach(System.out::println); } } } → 도우미 메서드를 적절히 활용하자.\n// 코드 45-3 스트림을 적절히 활용하면 깔끔하고 명료해진다. (271쪽) public class HybridAnagrams { public static void main(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); try (Stream\u0026lt;String\u0026gt; words = Files.lines(dictionary)) { words.collect(groupingBy(word -\u0026gt; alphabetize(word))) .values().stream() .filter(group -\u0026gt; group.size() \u0026gt;= minGroupSize) .forEach(g -\u0026gt; System.out.println(g.size() + \u0026#34;: \u0026#34; + g)); } } private static String alphabetize(String s) { char[] a = s.toCharArray(); Arrays.sort(a); return new String(a); } } 스트림과 람다 람다에서는 타입을 자주 생략하므로 매개변수 이름을 잘 지어야 한다. 도우미 메서드를 적절히 활용하는 일의 중요성은 일반 반복 코드보다는 스트림 파이프라인에서 훨씬 크다. 스트림을 쓰면 좋은 것 원소들의 시퀀스를 일관되게 변환한다. 원소들의 시퀀스를 필터링한다. 원소들의 시퀀스를 하나의 연산을 사용해 결합한다. 원소들의 시퀀스를 컬렉션에 모은다. 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다. 스트림(+람다)이 할 수 없는 것 람다에선 final 이거나 사실상 final인 변수만 읽을 수 있고, 지역변수를 수정할 수 없다. 람다는 흐름 제어가 불가능하지만, 코드 블록에서는 가능하다. 스트림과 반복문 중 어떤 쪽이 나은지 확신하기 어렵다면 직접 구현해 보고 나은 쪽을 선택하자.\n아이템 46: 스트림에서는 부작용없는 함수를 사용하라 함수형 패러다임을 지키려면 부작용없는 순수함수를 사용해야 한다.\n순수함수는 입력만이 결과에 영향을 주는 함수이며, 함수 외부의 가변 상태를 참조하지 않고 외부의 상태도 변경하지 않는 함수이다.\n스트림 파이프라인에 사용할 함수는 부작용이 없는 순수 함수를 사용해야 한다.\nforEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자. 잘못된 예 // 코드 46-1 스트림 패러다임을 이해하지 못한 채 API만 사용했다 - 따라 하지 말 것! (277쪽) Map\u0026lt;String, Long\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); try (Stream\u0026lt;String\u0026gt; words = new Scanner(file).tokens()) { words.forEach(word -\u0026gt; { freq.merge(word.toLowerCase(), 1L, Long::sum); }); } 좋은 예 // 코드 46-2 스트림을 제대로 활용해 빈도표를 초기화한다. (278쪽) Map\u0026lt;String, Long\u0026gt; freq; try (Stream\u0026lt;String\u0026gt; words = new Scanner(file).tokens()) { freq = words .collect(groupingBy(String::toLowerCase, counting())); } 수집기를 사용하면 스트림의 원소를 손쉽게 컬렉션으로 모을 수 있다.\ntoList(), toSet(), toMap() \u0026hellip; 아이템 47: 반환 타입으로는 스트림보다 컬렉션이 낫다 스트림은 반복을 지원하지 않는다. Iterable을 사용해 우회할 수 있으나, 코드가 지저분해지고 읽기 힘들어진다.\n어댑터를 사용해서 Iterable ↔ Stream간 상호 변환을 간단히 구현할 수 있다. // 스트림 \u0026lt;-\u0026gt; 반복자 어댑터 (285-286쪽) public class Adapters { // 코드 47-3 Stream\u0026lt;E\u0026gt;를 Iterable\u0026lt;E\u0026gt;로 중개해주는 어댑터 (285쪽) public static \u0026lt;E\u0026gt; Iterable\u0026lt;E\u0026gt; iterableOf(Stream\u0026lt;E\u0026gt; stream) { return stream::iterator; } // 코드 47-4 Iterable\u0026lt;E\u0026gt;를 Stream\u0026lt;E\u0026gt;로 중개해주는 어댑터 (286쪽) public static \u0026lt;E\u0026gt; Stream\u0026lt;E\u0026gt; streamOf(Iterable\u0026lt;E\u0026gt; iterable) { return StreamSupport.stream(iterable.spliterator(), false); } } 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 하위 타입을 사용하는 것이 일반적으로 최선이다. 원소를 이미 컬렉션에 담아 관리하고 있거나 원소 개수가 적다면 표준 컬렉션에 담아서 반환하고, 그렇지 않다면 전용 컬렉션을 구현하는 것을 검토하자. → 반환 타입은 스트림보다는, 반복과 스트림을 모두 지원할 수 있는 컬렉션 타입이 낫다.\n아이템 48: 스트림 병렬화는 주의해서 적용하라 스트림은 .parallel() 로 쉽게 병렬화할 수 있지만, 마구잡이로 사용할 경우 오히려 성능을 해치거나, 잘못된 결과를 만들 수 있다.\n데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다. 대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나, 배열, IntRange, LongRange일 때 병렬화의 효과가 가장 좋다. 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있고, 참조 지역성이 뛰어나기 때문 파이프라인이 수행하는 작업이 병렬화에 드는 추가 비용을 상쇄하지 못한다면 성능 향상에는 도움이 되지 않는다. ","permalink":"https://junbread.win/posts/2021/effective-java-07/","summary":"아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.\nCollections.sort(words, new Comparator\u0026lt;String\u0026gt;() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.\nCollections.sort(words, (s1, s2) -\u0026gt; Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (\u0026#34;+\u0026#34;, (x, y) -\u0026gt; x + y), MINUS (\u0026#34;-\u0026#34;, (x, y) -\u0026gt; x - y), TIMES (\u0026#34;*\u0026#34;, (x, y) -\u0026gt; x * y), DIVIDE(\u0026#34;/\u0026#34;, (x, y) -\u0026gt; x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this.","title":"이펙티브 자바 7장 정리"},{"content":"아이템 34: int 상수 대신 열거 타입을 사용하라 Java 1.5 Enum 등장 전 사용되던 int enum 패턴\npublic static final int APPLE_FUJI = 0; public static final int APPLE_PIPPIN = 1; public static final int APPLE_GRANNY_SMITH = 2; public static final int ORANGE_NAVEL = 0; public static final int ORANGE_TEMPLE = 1; public static final int ORANGE_BLOOD = 2; 타입 안전을 보장할 방법이 없다. 표현 방식이 까다롭다. toString(), 디버거 등에서는 그냥 아무 의미 없는 상수로 보인다. 그렇다고 문자열 상수를 사용하자니, 성능 저하 + 문자열 하드코딩의 위험이 있다. → Enum 타입을 사용하자.\npublic enum Apple { FUJI, PIPPIN, GRANNY_SMITH } public enum Orange { NAVEL, TEMPLE, BLOOD } Enum 타입의 장점 Java의 Enum은 완전한 클래스이다. 밖에서 접근 가능한 생성자가 없기 때문에, 사실상 final이다. 따라서 오직 하나만 존재함이 보장된다. 컴파일타임 타입 안전성을 제공한다. 출력하기에 적합한 문자열을 제공한다. 상수별 메서드 구현 // 코드 34-6 상수별 클래스 몸체(class body)와 데이터를 사용한 열거 타입 (215-216쪽) public enum Operation { PLUS(\u0026#34;+\u0026#34;) { public double apply(double x, double y) { return x + y; } }, MINUS(\u0026#34;-\u0026#34;) { public double apply(double x, double y) { return x - y; } }, TIMES(\u0026#34;*\u0026#34;) { public double apply(double x, double y) { return x * y; } }, DIVIDE(\u0026#34;/\u0026#34;) { public double apply(double x, double y) { return x / y; } }; private final String symbol; Operation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; } public abstract double apply(double x, double y); // 코드 34-7 열거 타입용 fromString 메서드 구현하기 (216쪽) private static final Map\u0026lt;String, Operation\u0026gt; stringToEnum = Stream.of(values()).collect( toMap(Object::toString, e -\u0026gt; e)); // 지정한 문자열에 해당하는 Operation을 (존재한다면) 반환한다. public static Optional\u0026lt;Operation\u0026gt; fromString(String symbol) { return Optional.ofNullable(stringToEnum.get(symbol)); } 전략 열거 타입 패턴 enum 인스턴스별로 \u0026lsquo;전략\u0026rsquo;을 선택하도록 하는 것 열거 타입 상수 일부가 같은 동작을 공유할 때 유용하다. // 코드 34-9 전략 열거 타입 패턴 (218-219쪽) enum PayrollDay { MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY), THURSDAY(WEEKDAY), FRIDAY(WEEKDAY), SATURDAY(WEEKEND), SUNDAY(WEEKEND); private final PayType payType; PayrollDay(PayType payType) { this.payType = payType; } int pay(int minutesWorked, int payRate) { return payType.pay(minutesWorked, payRate); } // 전략 열거 타입 enum PayType { WEEKDAY { int overtimePay(int minsWorked, int payRate) { return minsWorked \u0026lt;= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2; } }, WEEKEND { int overtimePay(int minsWorked, int payRate) { return minsWorked * payRate / 2; } }; abstract int overtimePay(int mins, int payRate); private static final int MINS_PER_SHIFT = 8 * 60; int pay(int minsWorked, int payRate) { int basePay = minsWorked * payRate; return basePay + overtimePay(minsWorked, payRate); } } public static void main(String[] args) { for (PayrollDay day : values()) System.out.printf(\u0026#34;%-10s%d%n\u0026#34;, day, day.pay(8 * 60, 1)); } } 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 Enum을 사용하자. Enum의 상수 개수가 고정불변일 필요는 없다. 나중에 상수가 추가되어도 바이너리 수준에서 호환되도록 설계되었기 때문 아이템 35: ordinal 메서드 대신 인스턴스 필드를 사용하라 Enum 상수에 연결된 값은 Enum.ordinal() 메서드를 사용해서 얻으면 안 된다. 상수 순서가 바뀔 경우 기존 코드가 깨지고, 중간에 값을 비워둘 수도 없다. (DB에 저장할 때도 순서를 그대로 저장하면 안 된다.) public enum Ensemble{ SOLO, DUET, TRIO, QUARTET, ..., OCTET; public int numberOfMusicians(){ return ordinal() + 1; } } public enum Ensemble{ SOLO(1), DUET(2), TRIO(3), QUARTET(4); private final int numberOfMusicians; Ensemble(int size) { this.numberOfMusicians = size; } public int numberOfMusicians(){ return numberOfMusicians; } } 아이템 36: 비트 필드 대신 EnumSet을 사용하라 열거 상수가 집합으로 사용할 경우, 예전에는 비트 필드 enum 패턴을 사용했다.\npublic class Text { public static final int STYLE_BOLD = 1 \u0026lt;\u0026lt; 0; // 1 public static final int STYLE_ITALIC = 1 \u0026lt;\u0026lt; 1; // 2 public static final int STYLE_UNDERLINE = 1 \u0026lt;\u0026lt; 2; // 4 public static final int STYLE_STRIKETHROUGH = 1 \u0026lt;\u0026lt; 3; // 8 // 매개변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR한 값이다. public void applyStyles(int styles) {...} } text.applyStyles(STYLE_BOLD | STYLE_ITALIC); String으로 출력하거나 디버거에서 의미를 직관적으로 인식하기 어렵다. 최대 몇 비트가 필요한지 예측해야 한다. → EnumSet을 사용하자.\n내부 구현은 비트 필드와 유사한 형태로 구현되어 있어 효율성과 안전성 모두 만족한다. public class Text { public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH } public void applyStyles(Set\u0026lt;Style\u0026gt; styles) {...} } text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC)); 아이템 37: ordinal 인덱싱 대신 EnumMap을 사용하라 Enum.ordinal() 메서드를 배열 인덱스로 사용하면 위험하다.\nSet\u0026lt;Plant\u0026gt;[] plantByLifeCycle = (Set\u0026lt;Plant\u0026gt;[]) new Set[Plant.LifeCycle.values().length]; for (int i = 0; i \u0026lt; plantsByLifeCycle.length; i++) { plantsByLifeCycle[i] = new HashSet\u0026lt;\u0026gt;(); } for (plant p : garden) { plantsByLifeCycle[p.lifeCycle.ordinal()].add(p); } // 결과 출력 for (int i = 0; i \u0026lt; plantsByLifeCycle.length; i++) { System.out.printf(\u0026#34;%s: %s%n\u0026#34;, Plant.LifeCycle.values()[i], plantsByLifeCycle[i]); } 비검사 형변환을 수행한다. 배열을 직접 사용했기 때문에 각 인덱스의 의미를 설명하는 레이블을 직접 달아야 한다. 정확한 정수값을 사용한다는 것을 직접 보증해야 한다. ordinal()은 상수 선언 순서에 따라 반환값이 바뀐다. → EnumMap을 사용하자.\nEnumMap 열거 타입을 키로 사용하도록 설계된 아주 빠른 Map 구현체\nMap\u0026lt;Plant.LifeCycle, Set\u0026lt;Plant\u0026gt;\u0026gt; plantsByLifeCycle = new EnumMap\u0026lt;\u0026gt;(Plant.LifeCycle.class); for (Plant.LifeCycle lc : Plant.LifeCycle.values()) { plantsByLifeCycle.put(lc, new HashSet\u0026lt;\u0026gt;()); } for (Plant p : garden) { plantsByLifeCycle.get(p.lifeCycle).add(p); } System.out.println(plantsByLifeCycle); 내부 구현 방식을 숨겨 배열 사용 시의 성능과 Map의 타입 안정성을 모두 만족한다. 맵의 키인 열거 타입이 그 자체로 출력용 문자열을 제공한다. 스트림을 사용해 맵을 관리하면 코드를 더 줄일 수 있다.\n//HashMap을 이용한 데이터와 열거타입 매핑 Arrays.stream(garden) .collect(groupingBy(p -\u0026gt; p.lifeCycle)) //EnumMap을 이용해 데이터와 열거타입 매핑 Arrays.stream(garden) .collect(groupingBy( p -\u0026gt; p.lifeCycle, () -\u0026gt; new EnumMap\u0026lt;\u0026gt;(LifeCycle.class), toSet()) ); 다차원 관계는 중첩된 EnumMap으로 표현할 수 있다.\n// 코드 37-5 배열들의 배열의 인덱스에 ordinal()을 사용 - 따라 하지 말 것! public enum Phase { SOLID, LIQUID, GAS; public enum Transition { MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT; // 행은 from의 ordinal을, 열은 to의 ordinal을 인덱스로 쓴다. private static final Transition[][] TRANSITIONS = { { null, MELT, SUBLIME }, { FREEZE, null, BOIL }, { DEPOSIT, CONDENSE, null } }; // 한 상태에서 다른 상태로의 전이를 반환한다. public static Transition from(Phase from, Phase to) { return TRANSITIONS[from.ordinal()][to.ordinal()]; } } } // 코드 37-6 중첩 EnumMap으로 데이터와 열거 타입 쌍을 연결했다. public enum Phase { SOLID, LIQUID, GAS; public enum Transition { MELT(SOLID, LIQUID), FREEBZ(LIQUID, SOLID), BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID), SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID); private final Phase from; private final Phase to; Transition(Phase from, Phase to) { this.from = from; this.to = to; } // 상전이 맵을 초기화한다. private static final Map\u0026lt;Phase, Map\u0026lt;Phase, Transition\u0026gt;\u0026gt; m = Stream.of(values()).collect(groupingBy(t -\u0026gt; t.from, () -\u0026gt; new EnumMap\u0026lt;\u0026gt;(Phase.class), toMap(t -\u0026gt; t.to, t -\u0026gt; t, (x, y) -\u0026gt; y, () -\u0026gt; new EnumMap\u0026lt;\u0026gt;(Phase.class)))); public static Transition from(Phase from, Phase to) { return m.get(from).get(to); } } } 아이템 38: 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라 Enum을 확장하는 것은 일반적으로 좋지 않은 생각이지만, 필요할 경우 인터페이스를 이용할 수 있다.\n기존 Enum을 인터페이스를 구현하도록 만든 뒤, 확장할 Enum은 해당 인터페이스를 구현한 새로운 Enum으로 구성 사용 시에는 인터페이스를 참조한다. public interface Operation { double apply(double x, double y); } public enum BasicOperation implements Operation { PLUS(\u0026#34;+\u0026#34;) { public double apply(double x, double y) { return x + y; } }, MINUS(\u0026#34;-\u0026#34;) { public double apply(double x, double y) { return x - y; } }, TIMES(\u0026#34;*\u0026#34;) { public double apply(double x, double y) { return x * y; } }, DIVIDE(\u0026#34;/\u0026#34;) { public double apply(double x, double y) { return x / y; } }; private final String symbol; } public enum ExtendedOperation implements Operation { EXP(\u0026#34;^\u0026#34;) { public double apply(double x, double y) { return Math.pow(x, y); } }, REMAINDER(\u0026#34;%\u0026#34;) { public double apply(double x, double y) { return x % y; } }; private final String symbol; } public static void main(String[] args) { double x = Double.parseDouble(args[0]); double y = Double.parseDouble(args[1]); test(ExtendedOperation.class, x, y); } private static \u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; Operation\u0026gt; void test(Class\u0026lt;T\u0026gt; opEnumType, double x, double y) { for (Operation op : opEnumType.getEnumConstants()) { System.out.printf(\u0026#34;%f %s %f = %f%n\u0026#34;, x, op, y, op.apply(x, y)); } } Enum은 final이므로 구현을 상속할 수 없기 때문에, 코드 중복이 많아지는 경우 헬퍼 클래스로 분리하는 것이 좋다.\n아이템 39: 명명패턴보다 애너테이션을 사용하라 도구나 프레임워크가 특별히 다루어야 할 프로그램 요소에는 전통적으로 구분되는 명명 패턴을 사용\ne.g. JUnit 3: 모든 테스트 메서드는 test로 시작해야 한다.\n오타에 취약하다. 올바른 프로그램 요소에서만 사용될 보장이 없다. 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다. → 애너테이션을 사용하자.\n// 코드 39-1 마커(marker) 애너테이션 타입 선언 (238쪽) import java.lang.annotation.*; /** * 테스트 메서드임을 선언하는 애너테이션이다. * 매개변수 없는 정적 메서드 전용이다. */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Test { } // 코드 39-2 마커 애너테이션을 사용한 프로그램 예 (239쪽) public class Sample { @Test public static void m1() { } // 성공해야 한다. public static void m2() { } @Test public static void m3() { // 실패해야 한다. throw new RuntimeException(\u0026#34;실패\u0026#34;); } public static void m4() { } // 테스트가 아니다. @Test public void m5() { } // 잘못 사용한 예: 정적 메서드가 아니다. public static void m6() { } @Test public static void m7() { // 실패해야 한다. throw new RuntimeException(\u0026#34;실패\u0026#34;); } public static void m8() { } } public class RunTests { public static void main(String[] args) throws Exception { int tests = 0; int passed = 0; Class\u0026lt;?\u0026gt; testClass = Class.forName(args[0]); for (Method m : testClass.getDeclaredMethods()) { if (m.isAnnotationPresent(Test.class)) { tests++; try { m.invoke(null); passed++; } catch (InvocationTargetException wrappedExc) { Throwable exc = wrappedExc.getCause(); System.out.println(m + \u0026#34; 실패: \u0026#34; + exc); } catch (Exception exc) { System.out.println(\u0026#34;잘못 사용한 @Test: \u0026#34; + m); } } } System.out.printf(\u0026#34;성공: %d, 실패: %d%n\u0026#34;, passed, tests - passed); } } 애너테이션의 의미 애너테이션은 클래스의 의미에 직접 영향을 주지는 않는다. 애너테이션에 관심 있는 프로그램에 추가 정보를 제공할 뿐이다. 메타 애너테이션 애너테이션 선언에 다는 애너테이션\n@Retention: 애너테이션의 범위를 지정한다. RUNTIME, CLASS, SOURCE @Target: 애너테이션이 적용될 수 있는 위치를 제한한다. PACKAGE, TYPE, CONSTRUCTOR, FIELD, METHOD, ANNOTATION_TYPE, LOCAL_VARIABLE, PARAMETER, TYPE_PARAMETER, TYPE_USE @Inherited: 자식 클래스가 부모 클래스에 달린 애너테이션을 가지도록 한다. @Repeatable: 반복해서 동일한 애너테이션을 달 수 있다. (후술) 매개변수를 받는 애너테이션 /** * 명시한 예외를 던져야만 성공하는 테스트 메서드용 애너테이션 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface ExceptionTest { Class\u0026lt;? extends Throwable\u0026gt; value(); } // 코드 39-5 매개변수 하나짜리 애너테이션을 사용한 프로그램 (241쪽) public class Sample2 { @ExceptionTest(ArithmeticException.class) public static void m1() { // 성공해야 한다. int i = 0; i = i / i; } @ExceptionTest(ArithmeticException.class) public static void m2() { // 실패해야 한다. (다른 예외 발생) int[] a = new int[0]; int i = a[1]; } @ExceptionTest(ArithmeticException.class) public static void m3() { } // 실패해야 한다. (예외가 발생하지 않음) } // 마커 애너테이션과 매개변수 하나짜리 애너태이션을 처리하는 프로그램 (241-242쪽) public class RunTests { public static void main(String[] args) throws Exception { int tests = 0; int passed = 0; Class\u0026lt;?\u0026gt; testClass = Class.forName(args[0]); for (Method m : testClass.getDeclaredMethods()) { if (m.isAnnotationPresent(Test.class)) { tests++; try { m.invoke(null); passed++; } catch (InvocationTargetException wrappedExc) { Throwable exc = wrappedExc.getCause(); System.out.println(m + \u0026#34; 실패: \u0026#34; + exc); } catch (Exception exc) { System.out.println(\u0026#34;잘못 사용한 @Test: \u0026#34; + m); } } if (m.isAnnotationPresent(ExceptionTest.class)) { tests++; try { m.invoke(null); System.out.printf(\u0026#34;테스트 %s 실패: 예외를 던지지 않음%n\u0026#34;, m); } catch (InvocationTargetException wrappedEx) { Throwable exc = wrappedEx.getCause(); Class\u0026lt;? extends Throwable\u0026gt; excType = m.getAnnotation(ExceptionTest.class).value(); if (excType.isInstance(exc)) { passed++; } else { System.out.printf( \u0026#34;테스트 %s 실패: 기대한 예외 %s, 발생한 예외 %s%n\u0026#34;, m, excType.getName(), exc); } } catch (Exception exc) { System.out.println(\u0026#34;잘못 사용한 @ExceptionTest: \u0026#34; + m); } } } System.out.printf(\u0026#34;성공: %d, 실패: %d%n\u0026#34;, passed, tests - passed); } } 배열 매개변수 애너테이션 매개변수를 배열로 받거나, @Repeatable 메타 애너테이션을 사용해 여러 개의 파라미터를 받을 수 있다. 배열로 선언된 매개변수에 하나만 전달하는 경우에는 중괄호로 묶어줄 필요가 없다. 반복 가능 애너테이션 자바 8부터 도입된 @Repeatable 메타 애너테이션을 적용하면 같은 애너테이션을 여러 번 적용할 수 있다.\n@Repeatable을 단 애너테이션을 반환하는 컨테이너 애너테이션을 하나 더 정의하고, 컨테이너 애너테이션의 class 객체를 매개변수로 전달해야 한다. @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Repeatable(ExceptionTestContainer.class) public @interface ExceptionTest { Class\u0026lt;? extends Throwable\u0026gt; value(); } @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface ExceptionTestContainer { ExceptionTest[] value(); } 컨테이너 애너테이션 타입에는 적절한 보존 정책과 적용 대상 (@Retention, @Target)을 명시해야 한다.\n반복 가능 애너테이션을 하나만 달았을 때와 여러 번 달았을 때는 다른 애너테이션 타입이 적용된다.\n메서드별로 동작이 달라지기 때문에 주의해야 한다. getAnnotationByType은 구분하지 않지만, isAnnotationPresent 메서드는 구분한다. public class RunTests { public static void main(String[] args) throws Exception { int tests = 0; int passed = 0; Class testClass = Class.forName(args[0]); for (Method m : testClass.getDeclaredMethods()) { if (m.isAnnotationPresent(Test.class)) { tests++; try { m.invoke(null); passed++; } catch (InvocationTargetException wrappedExc) { Throwable exc = wrappedExc.getCause(); System.out.println(m + \u0026#34; 실패: \u0026#34; + exc); } catch (Exception exc) { System.out.println(\u0026#34;잘못 사용한 @Test: \u0026#34; + m); } } // 코드 39-10 반복 가능 애너테이션 다루기 (244-245쪽) if (m.isAnnotationPresent(ExceptionTest.class) || m.isAnnotationPresent(ExceptionTestContainer.class)) { tests++; try { m.invoke(null); System.out.printf(\u0026#34;테스트 %s 실패: 예외를 던지지 않음%n\u0026#34;, m); } catch (Throwable wrappedExc) { Throwable exc = wrappedExc.getCause(); int oldPassed = passed; ExceptionTest[] excTests = m.getAnnotationsByType(ExceptionTest.class); for (ExceptionTest excTest : excTests) { if (excTest.value().isInstance(exc)) { passed++; break; } } if (passed == oldPassed) System.out.printf(\u0026#34;테스트 %s 실패: %s %n\u0026#34;, m, exc); } } } System.out.printf(\u0026#34;성공: %d, 실패: %d%n\u0026#34;, passed, tests - passed); } 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.\n아이템 40: @Override 애너테이션을 일관되게 사용하라 상위 타입의 메서드를 재정의했음을 뜻하는 @Override 메서드를 일관되게 사용하면 많은 버그를 예방할 수 있다.\n// 코드 40-1 영어 알파벳 2개로 구성된 문자열(바이그램)을 표현하는 클래스 - 버그를 찾아보자. (246쪽) public class Bigram { private final char first; private final char second; public Bigram(char first, char second) { this.first = first; this.second = second; } public boolean equals(Bigram b) { return b.first == first \u0026amp;\u0026amp; b.second == second; } public int hashCode() { return 31 * first + second; } public static void main(String[] args) { Set\u0026lt;Bigram\u0026gt; s = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) for (char ch = \u0026#39;a\u0026#39;; ch \u0026lt;= \u0026#39;z\u0026#39;; ch++) s.add(new Bigram(ch, ch)); System.out.println(s.size()); } } equals() 메서드의 파라미터 타입을 Object로 선언하지 않아 메서드 재정의가 아니라 다중정의가 되어 예상하지 않은 방식으로 작동한다. → 상위 클래스의 메서드를 재정의하고자 하는 모든 곳에 @Override 애너테이션을 붙이면 컴파일 타임에 실수를 예방할 수 있다.\n아이템 41: 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라 마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다.\n마커 인터페이스의 장점 마커 인터페이스는 구현한 클래스의 인스턴스를 구분하는 타입으로 쓸 수 있으나, 애너테이션은 그렇지 않다. 적용 대상을 좀 더 정밀하게 지정할 수 있다. 마커 애너테이션의 장점 애너테이션 프레임워크의 지원을 받을 수 있다. → 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있다면 인터페이스로, 그렇지 않다면 애너테이션으로 작성하자.\n","permalink":"https://junbread.win/posts/2021/effective-java-06/","summary":"아이템 34: int 상수 대신 열거 타입을 사용하라 Java 1.5 Enum 등장 전 사용되던 int enum 패턴\npublic static final int APPLE_FUJI = 0; public static final int APPLE_PIPPIN = 1; public static final int APPLE_GRANNY_SMITH = 2; public static final int ORANGE_NAVEL = 0; public static final int ORANGE_TEMPLE = 1; public static final int ORANGE_BLOOD = 2; 타입 안전을 보장할 방법이 없다. 표현 방식이 까다롭다. toString(), 디버거 등에서는 그냥 아무 의미 없는 상수로 보인다.","title":"이펙티브 자바 6장 정리"},{"content":"제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.\n아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.\n→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.\npublic class Raw { public static void main(String[] args) { List\u0026lt;String\u0026gt; strings = new ArrayList\u0026lt;\u0026gt;(); unsafeAdd(strings, Integer.valueOf(42)); String s = strings.get(0); // 컴파일러가 자동으로 형변환 코드를 넣어준다. } private static void unsafeAdd(List list, Object o) { list.add(o); } } List, List\u0026lt;Object\u0026gt;의 차이 List는 제네릭과 무관하다. List\u0026lt;Object\u0026gt;는 모든 타입을 허용한다고 명시적으로 컴파일러에게 정보를 전달해주는 것이다. 원소의 타입을 모른 채 사용하고 싶다면? 비한정적 와일드카드 타입을 사용하자. List\u0026lt;?\u0026gt; 이 경우 리스트에 아무 원소도 넣을 수 없게 된다. 이런 제약을 받아들일 수 없다면 제네릭 메서드, 한정적 와일드카드 타입을 이용하자. 단, 클래스 리터럴을 사용하거나, instanceof 연산자 사용시에는 로 타입을 사용해야 한다. (실체화 불가능) 아이템 27: 비검사 경고를 제거하라 비검사 경고는 중요하니 무시하지 말자. 잠재적 ClassCastException 오류를 일으킬 수 있다.\n경고를 제거할 수 없지만 타입이 안전하다고 확신할 수 있다면 @SuppressWarnings(\u0026quot;unchecked\u0026quot;) 어노테이션을 붙여 경고를 숨기자. 가능한 좁은 범위에 적용해야 한다. (오류 가능성을 줄이기 위해) 경고를 무시해도 안전한 이유를 주석으로 같이 남겨두도록 하자. 아이템 28: 배열보다는 리스트를 사용하라 배열 vs 제네릭 배열은 공변(covariant)이다. Sub 클래스가 Super 라는 클래스의 하위 타입이라면, 배열 Sub[]은 배열 Super[]의 하위 타입이 된다. 제네릭은 불공변(invariant)이다. 서로 다른 Type1과 Type2가 있을 때, List\u0026lt;Type1\u0026gt;은 List\u0026lt;Type2\u0026gt;의 상위 타입도 하위 타입도 아니다. Object[] objectArray = new Long[1]; ObjectArray[0] = \u0026#34;타입이 달라 넣을 수 없다.\u0026#34;; // ArrayStoreException을 던진다. List\u0026lt;Object\u0026gt; ol = new ArrayList\u0026lt;Long\u0026gt;(); // 호환되지 않는 타입이다. ol.add(\u0026#34;타입이 달라 넣을 수 없다.\u0026#34;); 배열에서는 위와 같은 실수를 런타임에야 알 수 있지만, 리스트는 코드를 실행하기 전에 알 수 있다.\n배열은 실체화된다. 런타임에도 원소의 타입을 인지하고 확인한다. 제네릭은 런타임 시에 타입이 소거된다. 제네릭 지원 전의 레거시 코드와 함께 사용하기 위함 제네릭 배열을 생성할 수 없는 이유 제네릭 배열은 타입 안전하지 않다.\nList\u0026lt;String\u0026gt;[] stringLists = new List\u0026lt;String\u0026gt;[1]; // (1) List\u0026lt;Integer\u0026gt; intList = List.of(42); // (2) Object[] objects = stringLists; // (3) objects[0] = intList; // (4) String s = stringLists[0].get(0); // (5) (2)는 원소가 하나인 리스트를 생성했다. (3)은 (1)을 Object 배열에 할당한다. 배열은 공변이니 아무 문제없다. (4)는 (2)에서 생성한 인스턴스를 Object 배열의 첫 번째 원소로 저장한다. 제네릭은 소거 방식으로 구현되어서 성공한다. (5) (1)에서 List\u0026lt;String\u0026gt;만 담겠다고 했으나, 배열에는 현재 List\u0026lt;Integer\u0026gt;가 담겨있다. 첫 번째 원소를 꺼내어 String으로 형변환할 때 ClassCastException가 발생한다. E, List\u0026lt;E\u0026gt;, List\u0026lt;String\u0026gt;과 같은 타입을 실체화 불가 타입(non-reifiable type) 이라고 한다.\n제네릭의 소거 특성으로 인해 실체화되지 않아 런타임 시에 컴파일 타임보다 타입 정보를 적게 갖는다. 제네릭과 배열은 궁합이 맞지 않기 때문에, 가급적 함께 사용하지 않고 대신 리스트를 사용하는 것이 좋다.\n아이템 29: 이왕이면 제네릭 타입으로 만들라 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 사용하기에도 편리하다.\n기존 클래스를 제네릭 타입으로 변경하는 방법 // Object 기반으로 구현된 스택 public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object result = elements[--size]; elements[size] = null; return result; } public boolean isEmpty() { return size == 0; } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } } // E[]를 이용한 제네릭 스택 (170-174쪽) public class Stack\u0026lt;E\u0026gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; // 코드 29-3 배열을 사용한 코드를 제네릭으로 만드는 방법 1 (172쪽) // 배열 elements는 push(E)로 넘어온 E 인스턴스만 담는다. // 따라서 타입 안전성을 보장하지만, // 이 배열의 런타임 타입은 E[]가 아닌 Object[]다! @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(E e) { ensureCapacity(); elements[size++] = e; } public E pop() { if (size == 0) throw new EmptyStackException(); E result = elements[--size]; elements[size] = null; // 다 쓴 참조 해제 return result; } public boolean isEmpty() { return size == 0; } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } // 코드 29-5 제네릭 Stack을 사용하는 맛보기 프로그램 (174쪽) public static void main(String[] args) { Stack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (String arg : args) stack.push(arg); while (!stack.isEmpty()) System.out.println(stack.pop().toUpperCase()); } } // Object[]를 이용한 제네릭 Stack (170-174쪽) public class Stack\u0026lt;E\u0026gt; { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(E e) { ensureCapacity(); elements[size++] = e; } // 코드 29-4 배열을 사용한 코드를 제네릭으로 만드는 방법 2 (173쪽) // 비검사 경고를 적절히 숨긴다. public E pop() { if (size == 0) throw new EmptyStackException(); // push에서 E 타입만 허용하므로 이 형변환은 안전하다. @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E result = (E) elements[--size]; elements[size] = null; // 다 쓴 참조 해제 return result; } public boolean isEmpty() { return size == 0; } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } // 코드 29-5 제네릭 Stack을 사용하는 맛보기 프로그램 (174쪽) public static void main(String[] args) { Stack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (String arg : args) stack.push(arg); while (!stack.isEmpty()) System.out.println(stack.pop().toUpperCase()); } 제네릭 타입은 타입 매개변수에 대부분의 제약을 두지 않지만 기본 타입은 사용할 수 없다.\n→ 박싱된 기본 타입을 통해 우회할 수 있다.\n타입 매개변수에 제약을 두는 한정적 타입 매개변수\n// java.util.concurrent.DelayQueue class DelayQueue\u0026lt;E extends Delayed\u0026gt; implements BlockingQueue\u0026lt;E\u0026gt; \u0026lt;E extends Delayed\u0026gt;는 Delayed의 하위 타입만 받겠다는 뜻이 된다. DelayQueue 자신과 이를 사용하는 클라이언트는 DelayQueue의 원소에서 형변환 없이 곧바로 Delayed 클래스의 메서드를 호출할 수 있다. 아이템 30: 이왕이면 제네릭 메서드로 만들라 메서드도 제네릭으로 만들 수 있다.\npublic static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; } // 코드 30-2 제네릭 메서드 (177쪽) public static \u0026lt;E\u0026gt; Set\u0026lt;E\u0026gt; union(Set\u0026lt;E\u0026gt; s1, Set\u0026lt;E\u0026gt; s2) { Set\u0026lt;E\u0026gt; result = new HashSet\u0026lt;\u0026gt;(s1); result.addAll(s2); return result; } 제네릭 싱글톤 팩터리 제네릭은 런타임에 타입 정보가 소거되기 때문에 하나의 객체를 어떤 타입으로든 매개변수화할 수 있다. 요청한 타입 매개변수에 맞도록 매번 그 객체의 타입을 변경해주는 정적 팩터리를 만들어야 한다. ex) Collections.emptySet() 재귀적 타입 한정 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정 주로 타입의 순서를 정하는 Comparable 인터페이스와 함께 쓰인다. \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt;는 “모든 타입 E는 자신과 비교할 수 있다” 라고 읽을 수 있다. // 코드 30-7 컬렉션에서 최댓값을 반환한다. - 재귀적 타입 한정 사용 (179쪽) public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(Collection\u0026lt;E\u0026gt; c) { if (c.isEmpty()) throw new IllegalArgumentException(\u0026#34;컬렉션이 비어 있습니다.\u0026#34;); E result = null; for (E e : c) if (result == null || e.compareTo(result) \u0026gt; 0) result = Objects.requireNonNull(e); return result; } 아이템 31: 한정적 와일드카드를 사용해 API 유연성을 높이라 매개변수화 타입은 불공변(invariant)이다.\nList\u0026lt;Object\u0026gt;를 파라미터로 받는 메서드의 인자로 List\u0026lt;String\u0026gt;을 전달할 수 없다. 제네릭을 좀 더 유연하게 사용할 수는 없을까?\n→ 입력 파라미터에 와일드카드 타입을 사용하자.\n한정적 와일드카드를 사용할 때는 PECS를 기억하자.\nProducer - Extend: 메서드의 매개변수가 생산자의 역할을 한다면 extend를 사용 Consumer - Super: 메서드의 매개변수가 소비자의 역할을 한다면 super를 사용 // 와일드카드 타입을 이용해 대량 작업을 수행하는 메서드를 포함한 제네릭 스택 (181-183쪽) public class Stack\u0026lt;E\u0026gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; // 코드 29-3 배열을 사용한 코드를 제네릭으로 만드는 방법 1 (172쪽) // 배열 elements는 push(E)로 넘어온 E 인스턴스만 담는다. // 따라서 타입 안전성을 보장하지만, // 이 배열의 런타임 타입은 E[]가 아닌 Object[]다! @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(E e) { ensureCapacity(); elements[size++] = e; } public E pop() { if (size==0) throw new EmptyStackException(); E result = elements[--size]; elements[size] = null; // 다 쓴 참조 해제 return result; } public boolean isEmpty() { return size == 0; } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } // // 코드 31-1 와일드카드 타입을 사용하지 않은 pushAll 메서드 - 결함이 있다! (181쪽) // public void pushAll(Iterable\u0026lt;E\u0026gt; src) { // for (E e : src) // push(e); // } // 코드 31-2 E 생산자(producer) 매개변수에 와일드카드 타입 적용 (182쪽) public void pushAll(Iterable\u0026lt;? extends E\u0026gt; src) { for (E e : src) push(e); } // // 코드 31-3 와일드카드 타입을 사용하지 않은 popAll 메서드 - 결함이 있다! (183쪽) // public void popAll(Collection\u0026lt;E\u0026gt; dst) { // while (!isEmpty()) // dst.add(pop()); // } // 코드 31-4 E 소비자(consumer) 매개변수에 와일드카드 타입 적용 (183쪽) public void popAll(Collection\u0026lt;? super E\u0026gt; dst) { while (!isEmpty()) dst.add(pop()); } // 제네릭 Stack을 사용하는 맛보기 프로그램 public static void main(String[] args) { Stack\u0026lt;Number\u0026gt; numberStack = new Stack\u0026lt;\u0026gt;(); Iterable\u0026lt;Integer\u0026gt; integers = Arrays.asList(3, 1, 4, 1, 5, 9); numberStack.pushAll(integers); Collection\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); numberStack.popAll(objects); System.out.println(objects); } } 주의사항 메서드의 리턴값으로 와일드카드를 사용하는 것은 피해야 한다. 클라이언트에서도 와일드카드 자료형을 사용해야 하기 때문 class swapTest { // 방법1) 비한정적 타입 매개변수 public static \u0026lt;E\u0026gt; void typeArgSwap(List\u0026lt;E\u0026gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } // 방법2) 비한정적 와일드카드 public static void wildcardSwap(List\u0026lt;?\u0026gt; list, int i, int j) { wildcardSwapHelper(list, i, j); } // 방법2-1) 와일드카드 형에는 null외에 어떤 값도 넣을 수 없다. // 방법1과 메서드 시그니처(이름과 파라미터)가 동일하다. private static \u0026lt;E\u0026gt; void wildcardSwapHelper(List\u0026lt;E\u0026gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } } 아이템 32: 제네릭과 가변인수를 함께 쓸 때는 신중하라 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 생긴다.\n→ 제네릭 타입 가변인수 배열에 값을 저장하게 되면 타입 안정성이 깨진다.\n// 코드 32-1 제네릭과 varargs를 혼용하면 타입 안전성이 깨진다! (191-192쪽) static void dangerous(List\u0026lt;String\u0026gt;... stringLists) { List\u0026lt;Integer\u0026gt; intList = List.of(42); Object[] objects = stringLists; objects[0] = intList; // 힙 오염 발생 String s = stringLists[0].get(0); // ClassCastException } public static void main(String[] args) { dangerous(List.of(\u0026#34;There be dragons!\u0026#34;)); } 컴파일 오류는 발생하지 않지만, 인수를 건네 호출하게 되면 ClassCastException이 발생한다. 해당 코드 부분에 컴파일러가 생성한 형변환 코드가 숨어 있기 때문이다. 제네릭 가변인수 배열을 안전하게 사용하는 방법 varargs 매개변수 배열이 순수하게 인수들을 전달한다면 그 메서드는 안전하다.\n메서드가 가변인수 메서드가 호출될 때 생성되는 varargs 매개변수 배열에 아무것도 저장하지 않아야 한다. 배열의 참조가 신뢰할 수 없는 곳에 노출되지 않아야 한다. (메서드를 재정의할 수 없어야 한다.) 아이템 33: 타입 안전 이종 컨테이너를 고려하라 제네릭에서 매개변수화되는 대상은 원소가 아닌 컨테이너 자신이다. 따라서 하나의 컨테이너에서 매개변수화할 수 있는 타입의 수가 제한된다.\n좀 더 유연한 구현을 위해서 타입 안전 이종 컨테이너 패턴을 사용할 수 있다.\n타입 안전 이종 컨테이너 패턴: 컨테이너 대신 키를 매개변수화한 다음에 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공한다.\n→ 컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴을 타입 토큰이라고 한다.\n// 타입 안전 이종 컨테이너 패턴 (199-202쪽) public class Favorites { // 코드 33-3 타입 안전 이종 컨테이너 패턴 - 구현 (200쪽) private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; favorites = new HashMap\u0026lt;\u0026gt;(); public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { favorites.put(Objects.requireNonNull(type), instance); } public \u0026lt;T\u0026gt; T getFavorite(Class\u0026lt;T\u0026gt; type) { return type.cast(favorites.get(type)); } // // 코드 33-4 동적 형변환으로 런타임 타입 안전성 확보 (202쪽) // public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { // favorites.put(Objects.requireNonNull(type), type.cast(instance)); // } // 코드 33-2 타입 안전 이종 컨테이너 패턴 - 클라이언트 (199쪽) public static void main(String[] args) { Favorites f = new Favorites(); f.putFavorite(String.class, \u0026#34;Java\u0026#34;); f.putFavorite(Integer.class, 0xcafebabe); f.putFavorite(Class.class, Favorites.class); String favoriteString = f.getFavorite(String.class); int favoriteInteger = f.getFavorite(Integer.class); Class\u0026lt;?\u0026gt; favoriteClass = f.getFavorite(Class.class); System.out.printf(\u0026#34;%s %x %s%n\u0026#34;, favoriteString, favoriteInteger, favoriteClass.getName()); } } 주의사항 타입 토큰을 로 타입으로 넘길 경우 타입 안정성이 깨진다.\n→ 동적 형변환으로 런타임 타입 안정성을 확보할 수 있다.\nf.putFavorite((Class)Integer.class, \u0026#34;Integer의 인스턴스가 아닙니다.\u0026#34;); int favoriteInteger = f.getFavorite(Integer.class); 실체화가 불가능한 타입은 넣을 수 없다. String이나 String[]은 저장할 수 있지만, List\u0026lt;String\u0026gt;은 저장할 수 없다. 우회하기 위한 방법으로는 슈퍼 타입 토큰을 사용할 수 있다. List\u0026lt;String\u0026gt; pets = Arrays.asList(\u0026#34;강아지\u0026#34;, \u0026#34;고양이\u0026#34;); f.putFavorite(new TypeRef\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(){}, pets); List\u0026lt;String\u0026gt; list = f.getFavorite(new TypeRef\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(){}); 슈퍼 타입 토큰 한마디로 요약하면, 런타임에 어떻게든 파라미터 타입에 대한 정보가 남아있도록 구현하는 것\n","permalink":"https://junbread.win/posts/2021/effective-java-05/","summary":"제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.\n아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.\n→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.\npublic class Raw { public static void main(String[] args) { List\u0026lt;String\u0026gt; strings = new ArrayList\u0026lt;\u0026gt;(); unsafeAdd(strings, Integer.","title":"이펙티브 자바 5장 정리"},{"content":"아이템 15: 클래스와 멤버의 접근 권한을 최소화하라 정보 은닉은 시스템을 구성하는 컴포넌트를 서로 독립시켜 준다.\n정보 은닉의 장점 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있다. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하고, 교체하는 데 부담이 줄어든다. 성능 최적화에 도움을 준다. 각 컴포넌트가 독립되어 있기 때문에 특정 컴포넌트만 최적화가 가능하다. 소프트웨어 재사용성을 높인다. 외부 의존 없이 동작하는 컴포넌트는 다른 환경에서도 사용이 쉽다. 대형 시스템 제작 난이도를 낮춘다. 미완성 상태에서도 개별 컴포넌트 동작을 검증할 수 있다. Java의 접근 제한자 private: 클래스 내부에서만 접근 가능 package-private (default): 패키지 내부의 모든 클래스에서 접근 가능 protected: 패키지 내부의 모든 클래스 + 자식 클래스에서 접근 가능 public: 모든 곳에서 접근 가능 주의점 public 클래스는 상수용 public static final 필드 외에 어떠한 public 필드도 가져서는 안 된다. public static final 필드의 경우 불변인지 점검해야 한다. ex) 배열 가변 객체를 참조하는 public static final 필드의 내부를 외부에서 변경 가능 unmodifiableList를 반환하거나, 복사본을 반환하는 접근자를 제공할 것 private static final Thing[] PRIVATE_VALUES = { ... }; public static final List\u0026lt;Thing\u0026gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)); private static final Thing[] PRIVATE_VALUES = { ... }; public static final Thing[] values() { return PRIVATE_VALUES.clone(); } 자바 9에서 새로 소개된 모듈에서는 export 되지 않은 모듈 내부의 public, protected 메서드를 모듈 외부에서 사용할 수 없다. 다만 jar 파일의 위치에 따라 무시되는 경우가 있으니 유의해야 한다.\n요약: 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.\n아이템 16: public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라 public으로 공개할 클래스라면 내부 필드를 숨기고 접근자(getter) 메서드를 제공하는 것이 좋다.\n→ 나중에 클래스의 내부 표현 방식을 언제든 바꿀 수 있기 때문\npublic 필드가 불변이라면 불변식을 해칠 수 있는 위험성은 덜하지만, 내부 구현을 바꾸기 힘들어진다는 단점은 동일하다.\n// 코드 16-3 불변 필드를 노출한 public 클래스 - 과연 좋은가? (103-104쪽) public final class Time { private static final int HOURS_PER_DAY = 24; private static final int MINUTES_PER_HOUR = 60; public final int hour; public final int minute; public Time(int hour, int minute) { if (hour \u0026lt; 0 || hour \u0026gt;= HOURS_PER_DAY) throw new IllegalArgumentException(\u0026#34;Hour: \u0026#34; + hour); if (minute \u0026lt; 0 || minute \u0026gt;= MINUTES_PER_HOUR) throw new IllegalArgumentException(\u0026#34;Min: \u0026#34; + minute); this.hour = hour; this.minute = minute; } package-private, nested private 클래스의 경우, 내부에서만 사용될 것이 보장되기 때문에 노출해도 괜찮다.\nLombok의 @Getter 사용하면 접근자를 편리하게 생성할 수 있다.\n요약: public 클래스의 경우 필드를 직접 노출하는 대신 접근자를 사용하자.\n아이템 17: 변경 가능성을 최소화하라 불변 객체가 가지는 장점 단순하다. 본질적으로 스레드 안전하다. 안심하고 공유할 수 있다. 내부 데이터를 공유할 수 있다. 실패 원자성을 제공한다. 불변 객체의 단점 값이 다르면 새로운 객체로 만들어야 하기 때문에, 변경하는 데 드는 비용보다 새로운 객체를 만드는 데 훨씬 더 비용이 비싼 경우에는 성능이 하락할 수 있다. ex) BigInteger\n→ 이 경우 가변 동반 클래스를 제공하자. ex) String - StringBuilder\n클래스를 불변으로 만들기 객체의 상태를 변경하는 메서드를 제공하지 않는다.\n클래스를 확장할 수 없도록 한다.\n클래스를 final로 선언 모든 생성자를 private, package-private로 선언하고 public 정적 팩터리를 제공 모든 필드를 final로 선언한다.\n모든 필드를 private로 선언한다.\n자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.\n불변으로 만들 수 없는 객체가 있다고 해도, 변경 가능한 부분을 최소한으로 하자.\nsetter 메서드는 꼭 필요한 경우에만 만들자.\n다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.\n생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.\n요약: 객체는 되도록 불변으로 만들고, 불가피하게 가변 객체로 만들더라도 변경할 수 있는 부분을 최소화하자.\n아이템 18: 상속보다는 컴포지션을 사용하라 상속의 단점 상속은 강력하지만, 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 상위 클래스가 확장을 충분히 고려하지 않으면 하위 클래스는 상위 클래스가 변경될 때마다 수정해주어야 한다. public class InstrumentedHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; { // 추가된 원소의 수 private int addCount = 0; public InstrumentedHashSet() { } public InstrumentedHashSet(int initCap, float loadFactor) { super(initCap, loadFactor); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } } 컴포지션 기존 클래스를 확장하는 대신, 새 클래스에 private으로 된 기존 클래스의 인스턴스를 참조하는 기법 새 클래스는 기존 클래스에 대응하는 메소드를 호출해 결과를 반환한다. 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 기존 클래스에 새 메소드가 추가되어도 전혀 영향받지 않는다. public class ForwardingSet\u0026lt;E\u0026gt; implements Set\u0026lt;E\u0026gt; { private final Set\u0026lt;E\u0026gt; s; public ForwardingSet(Set\u0026lt;E\u0026gt; s) { this.s = s; } public void clear() { s.clear(); } public boolean contains(Object o) { return s.contains(o); } public boolean isEmpty() { return s.isEmpty(); } public int size() { return s.size(); } public Iterator\u0026lt;E\u0026gt; iterator() { return s.iterator(); } public boolean add(E e) { return s.add(e); } public boolean containsAll(Collection\u0026lt;?\u0026gt; c) { return s.containsAll(c); } public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return s.addAll(c); } public boolean removeAll(Collection?\u0026gt; c) { return s.removeAll(c); } public boolean retainAll(Collection\u0026lt;?\u0026gt; c) { return s.retainAll(c); } public Object[] toArray() { return s.toArray(); } public \u0026lt;T\u0026gt; T[] toArray(T[] a) { return s.toArray(a); } @Override public boolean equals(Object o) { return s.equals(o); } @Override public int hashCode() { return s.hashCode(); } @Override public String toString() { return s.toString(); } } public class InstrumentedHashSet\u0026lt;E\u0026gt; extends ForwardingSet\u0026lt;E\u0026gt; { private int addCount = 0; public InstrumentedHashSet(Set\u0026lt;E\u0026gt; s) { super(s); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } } 상속은 반드시 하위 클래스가 상위 클래스의 \u0026lsquo;진짜\u0026rsquo; 하위 타입인 경우에만 쓰여야 한다. B가 A가 아니라면, A를 private 필드로 두고, A와는 다른 API를 제공해야 한다. 즉, A는 B의 필수 구성요소가 아니라 구현하는 방법 중 하나일 뿐이다.\n상속을 사용하기 전 자문해야 할 것 확장하려는 클래스의 API에 아무런 결함이 없는가? 결함이 있다면, 이 결함이 하위 클래스의 API까지 전파되어도 괜찮은가? 요약: 상속은 하위 클래스가 상위 클래스의 진짜 하위 타입인 경우에만 사용하고, 그렇지 않을 경우에는 컴포지션을 사용하자.\n아이템 19: 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라 상속용 클래스는 재정의할 수 있는 메서드를 내부적으로 어떻게 이용하는지 문서로 남겨야 한다. → @implSpec 태그를 붙이면 자바독이 생성해 준다.\n상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.\n상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안 된다.\n→ 예상치 못한 에러를 발생시킬 수가 있다.\npublic class Super { // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다. public Super() { overrideMe(); } public void overrideMe() { } } public final class Sub extends Super { // 초기화되지 않은 final 필드. 생성자에서 초기화한다. private final Instant instant; Sub() { instant = Instant.now(); } // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다. @Override public void overrideMe() { System.out.println(instant); } public static void main(String[] args) { Sub sub = new Sub(); sub.overrideMe(); } } Cloneable과 Serializable을 구현한 클래스의 경우 더 복잡하다. clone, readObject의 경우 새로운 객체를 만들기 때문에 생성자에서 재정의 가능 메서드 호출 금지와 동일한 제약사항을 가진다. Serializable의 경우 상속용 상위 클래스가 readResolve, writeReplace 구현하는 경우 private가 아닌 protected로 선언해야 하위 클래스에서 무시되지 않는다. 상속용으로 설계하지 않은 클래스는 상속을 금지하자. 상속을 허용하는 경우는 재정의 가능 메서드의 내부 구현을 상세하게 밝혀야 한다.\n아이템 20: 추상 클래스보다는 인터페이스를 우선하라 다중 구현의 두 가지 방법 추상 클래스, 인터페이스\n→ 추상 클래스를 구현하는 클래스는 반드시 추상 클래스의 하위 타입이 되어야 하기 때문에 유연성이 떨어진다.\n인터페이스가 가지는 장점 기존 클래스에도 손쉽게 구현할 수 있다: 추상 클래스의 경우 이미 다른 클래스를 상속받고 있다면 사용할 수 없다. 믹스인 정의에 안성맞춤이다. 계층구조가 없는 타입 프레임워크를 만들 수 있다. public interface Singer { AudioClip sing(Song s); } public interface Songwriter { Song compose(int chartPosition); } public interface SingerSongwriter extends Singer, SongWriter { AudioClip strum(); void actSensitive(); } 래퍼 클래스와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다. public abstract class AbstractMapEntry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { // 변경 가능한 엔트리는 이 메서드를 반드시 재정의해야 한다. @Override public V setValue(V value) { throw new UnsupportedOperationException(); } // Map.Entry.equals의 일반 규약을 구현한다. @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map.Entry)) return false; Map.Entry\u0026lt;?,?\u0026gt; e = (Map.Entry) o; return Objects.equals(e.getKey(), getKey()) \u0026amp;\u0026amp; Objects.equals(e.getValue(), getValue()); } // Map.Entry.hashCode의 일반 규약을 구현한다. @Override public int hashCode() { return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); } @Override public String toString() { return getKey() + \u0026#34;=\u0026#34; + getValue(); } } 아이템 21: 인터페이스는 구현하는 쪽을 생각해 설계하라 자바 8부터는 디폴트 메소드를 지원해 인터페이스에 메소드를 구현할 수 있게 되었다.\n주의점 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메소드를 만드는 것은 어렵다.\n디폴트 메소드는 컴파일에 성공하더라도, 기존 구현체에 런타임 오류를 발생시킬 수 있다.\n기존 인터페이스에 디폴트 메소드로 새 메소드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.\n→ 새 인터페이스에서의 디폴트 메소드는 표준적인 메소드 구현을 제공하는 데 아주 유용하다.\n아이템 22: 인터페이스는 타입을 정의하는 용도로만 사용하라 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 다시 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지 클라이언트에 얘기해주는 것이다. 인터페이스는 오직 이 용도로만 사용해야 한다.\n상수를 공유할 목적으로 다음과 같은 상수 인터페이스를 만드는 경우가 있다.\n// 상수 인터페이스 안티패턴 - 사용금지! public interface PhysicalConstants { // 아보가드로 수 (1/몰) static final double AVOGADROS_NUMBER = 6.022_140_857e23; // 볼츠만 상수 (J/K) static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23; // 전자 질량 (kg) static final double ELECTRON_MASS = 9.109_383_56e-31; } 사용자가 편의를 위해 특정 클래스에서 인터페이스를 구현한다면, 해당 클래스와 그 클래스의 하위 클래스의 모든 전역 네임스페이스가 인터페이스 상수로 오염된다.\n상수를 공개하는 방법 특정 클래스나 인터페이스에 강하게 연관된 상수라면, 그 클래스/인터페이스 자체에 추가 (ex. Integer.MAX_VALUE) 인스턴스화할 수 없는 유틸리티 클래스에 담아서 공개 아이템 23: 태그 달린 클래스보다는 클래스 계층구조를 활용하라 태그 달린 클래스 class Figure { enum Shape { RECTANGLE, CIRCLE }; final Shape shape; //태그 필드 double length; double width; double radius; Figure(double radius) { shape = Shape.CIRCLE; this.radius = radius; } Figure(double length, double width) { shape = Shape.RECTANGLE; this.length = length; this.width = width; } double area() { switch(shape) { case RECTANGLE: return length * width; case CIRCLE: return Math.PI * radius * radius; case default: throw new AssertionError(shape); } } } enum 선언, 태그 필드, switch 문 등 쓸데없는 코드가 많다. 여러 구현이 한 클래스에 혼합되어 있어서 가독성이 나쁘고, 메모리를 많이 사용한다. 새로운 의미를 추가하기 위해서 수정해야 하는 코드가 많다. → 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.\n클래스 계층구조로 변환 abstract class Figure { abstract double area(); } class Circle extends Figure { final double radius; Circle(double radius) { this.radius = radius; } @Override double area() { return Math.PI * radius * radius; } } class Rectangle extends Figure { final double length; final double width; Rectangle(double length , double width) { this.length = length; this.width = width; } @Override double area() { return length * width; } } 쓸데없는 코드가 없고 간결하다. 컴파일러의 도움을 받을 수 있다. 독립적으로 계층구조 확장이 가능하다. 아이템 24: 멤버 클래스는 되도록 static으로 만들라 중첩 클래스의 종류 정적 멤버 클래스 비정적 멤버 클래스 익명 클래스 지역 클래스 비정적 멤버 클래스의 인스턴스는 암묵적으로 바깥 클래스의 인스턴스와 연결된다.\n그래서 비정적 멤버 클래스의 인스턴스 메소드에서 바깥 인스턴스의 메소드를 호출하거나, 바깥 인스턴스의 참조를 가져올 수 있다. 이 과정에서 시간과 메모리 공간이 소비되고, 가비지 컬렉션이 바깥 인스턴스를 수거하지 못했을 경우 메모리 누수가 생길 수 있다. 따라서 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다. 비정적 멤버 클래스는 바깥 인스턴스 없이 생성될 수 없기 때문이다. 비정적 멤버 클래스 → 어댑터를 정의할 때 자주 쓰인다. 즉, 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용하는 것이다.\npublic class MySet\u0026lt;E\u0026gt; extends AbstractSet\u0026lt;E\u0026gt; { ... // 생략 @Override public Iterator\u0026lt;E\u0026gt; iterator() { return new MyIterator(); } private class MyIterator implements Iterator\u0026lt;E\u0026gt; { ... } } private 정적 멤버 클래스는 바깥 클래스가 표현하는 객체의 한 부분(구성요소)을 나타낼 때 쓴다. ex) Map.Entry\n중첩 클래스를 사용하는 경우 메서드 밖에서 사용해야 하거나 메서드 안에 정의하기에 너무 길다면 멤버 클래스 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적 멤버 클래스 그렇지 않으면 정적 멤버 클래스 중첩 클래스가 한 메소드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스 그렇지 않으면 지역 클래스 아이템 25: 톱레벨 클래스는 한 파일에 하나만 담으라 소스 파일 하나에는 반드시 톱레벨 클래스를 하나만 담자. 소스 파일을 어떤 순서로 컴파일하냐에 따라 다른 동작을 만들 수 있다.\n// Utensil.java class Utensil { static final String NAME = \u0026#34;pan\u0026#34;; } class Dessert { static final String NAME = \u0026#34;cake\u0026#34;; } // Dessert.java class Utensil { static final String NAME = \u0026#34;pot\u0026#34;; } class Dessert { static final String NAME = \u0026#34;pie\u0026#34;; } ","permalink":"https://junbread.win/posts/2021/effective-java-04/","summary":"아이템 15: 클래스와 멤버의 접근 권한을 최소화하라 정보 은닉은 시스템을 구성하는 컴포넌트를 서로 독립시켜 준다.\n정보 은닉의 장점 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있다. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하고, 교체하는 데 부담이 줄어든다. 성능 최적화에 도움을 준다. 각 컴포넌트가 독립되어 있기 때문에 특정 컴포넌트만 최적화가 가능하다. 소프트웨어 재사용성을 높인다. 외부 의존 없이 동작하는 컴포넌트는 다른 환경에서도 사용이 쉽다. 대형 시스템 제작 난이도를 낮춘다.","title":"이펙티브 자바 4장 정리"},{"content":"아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.\n각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.\n반사성: A.equals(A)가 참이다\n대칭성: A.equals(B)가 참이라면 B.equals(A)이다\npublic class Point { @Override boolean equals(Object o) { if (!(o instanceof Point)) return false; return ((Point) o).xxx == xxx; } } public class ColorPoint { @Override boolean equals(Object o) { if (!(o instanceof ColorPoint)) return false; return ((ColorPoint) o).xxx == xxx \u0026amp;\u0026amp; ((ColorPoint) o).yyy == yyy; } } 추이성: A.equals(B)이고 B.equals(C)이면 A.equals(C)이다\n구체 클래스를 확장하면서 동치 관계를 만족시킬 방법은 없다.\n→ 상속 대신 컴포지션을 사용하자.\n일관성: A.equals(B)의 결과는 언제나 같아야 한다\nequals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안 된다. equals에 네트워크를 통한 검사 로직이 들어 있다면? (null-아님): 모든 객체는 null과 같지 않다\n일반적인 equals 구현 방법 == 연산자로 자기 자신의 참조인지 확인 instanceof로 입력이 올바른 타입인지 확인 올바른 타입으로 캐스팅 핵심 필드들이 일치하는지 하나하나 검사 비교 비용이 낮은 필드부터 비교하기 요약 꼭 필요한 경우가 아니면 equals를 재정의하지 않는 것이 좋다. equals 재정의를 할 때에는 반사성, 대칭성, 추이성, 일관성, (null-아님)의 다섯 가지 규칙을 반드시 지켜야 한다.\n아이템 11: equals를 재정의하려거든 hashCode도 재정의하라 hashCode를 재정의하지 않을 경우 애플리케이션 동작에 이상을 일으킬 수 있다.\nhashCode에 관한 규약 equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.\nequals 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.\nequals 메서드가 다르다고 판단한 두 객체의 hashCode 값이 꼭 다를 필요는 없다.\n→ 그러나 서로 다른 hashCode 값이 나오면 해시 테이블의 성능이 향상될 수 있다.\nhashCode 구현시 주의사항 해시코드 계산에 핵심 필드가 빠지게 되면 해시 함수의 성능이 크게 감소할 수 있다. Lombok의 @EqualsAndHashCode 를 이용하면 일관적으로 equals와 hashCode 메서드를 재정의할 수 있다.\n요약 equals 재정의 시에는 hashCode를 항상 함께 재정의해야 한다.\n아이템 12: toString을 항상 제공하라 toString은 직접 사용하지 않더라도 디버거, 객체 직렬화 등 많은 곳에서 사용되므로 재정의하는 것이 좋다.\n좋은 toString 만들기 toString에는 가급적 클래스의 핵심 정보를 모두 제공해야 한다.\n주석으로 의도를 명확하게 밝히는 것이 좋다.\ntoString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공해야 한다.\n→ 그렇지 않으면 사실상 toString이 접근자 역할을 하게 되고, toString을 파싱하는 시도를 하게 된다.\n역시 Lombok의 @ToString을 이용하면 간편하게 toString을 재정의할 수 있다.\n요약 toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.\n아이템 13: clone 재정의는 주의해서 진행하라 clone의 명세는 허술하다 Cloneable은 아무런 메서드를 가지지 않는 인터페이스이지만, clone의 동작 방식을 결정한다. Object.clone()은 checked exception을 던지기 때문에 사용하기 불편하다. clone 메서드를 제대로 구현했는지 시스템적으로 검증할 방법이 없다. super.clone()을 호출했는지, 생성자를 호출했는지 컴파일러는 상관하지 않는다. clone 재정의 시 주의사항 clone 메소드는 사실상 생성자와 같은 효과를 낸다. 즉 clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다. 클래스가 가변 객체를 참조한다면 원본과 복제본이 가변 객체를 공유해도 되는지 확인하고, 깊은 복사를 구현해야 한다. 클래스가 Thread-safe하다면 clone 재정의 시에도 동기화에 신경써야 한다. Cloneable을 구현하는 클래스는 clone을 재정의해야 한다. 이 때 접근제어자를 public으로 바꾸고, 반환 타입을 클래스 자신으로 바꾸고, throws 절도 없애는 것이 좋다. 상속용 클래스는 Cloneable을 구현하게 하면 안 된다. 하위 클래스에서 clone을 지원할지 선택하게 하자. 복사 생성자와 복사 팩터리 자기 자신을 인수로 받는 생성자나, 유사한 방식의 정적 팩토리 메서드를 사용하면 clone의 단점이었던 허술한 스펙, final용법과 충돌, 불필요한 checked exception, 형변환 등을 해결할 수 있다.\npublic Point(Point point) { ... } public static Point newInstance(Point point) { ... } 요약 Cloneable 인터페이스와 clone은 허술하게 설계되어 있기 때문에 많은 문제를 내포하고 있다. 가급적 복사 생성자 방식을 사용하자.\n아이템 14: Comparable을 구현할지 고려하라 compareTo의 특징과 규칙 compareTo 메소드는 Object가 아닌 Comparable 인터페이스에 있다. compareTo 는 제네릭이고, 순서뿐 아니라 동치성도 비교할 수 있다. compareTo 메소드의 일반 규칙과 주의사항은 equals 규칙과 비슷하다. 반사성, 대칭성, 추이성을 충족해야 한다. (권장) compareTo를 이용한 동치성 테스트는 equals 결과와 같아야 한다. 구체 클래스를 확장한 경우 compareTo의 규칙을 지킬 수 없으며, 컴포지션으로 우회한다. compareTo 메서드 구현 시의 주의사항 기본 타입 클래스를 비교할 때도 가급적 박싱된 기본 타입 클래스에 추가된 compare 메서드를 이용하자. 값의 차를 기준으로 compareTo를 구현하는 경우 오버플로우, 부동소수점 오류 등 예상치 않은 결과를 낼 수 있다. Comparable을 구현하지 않은 클래스를 비교하거나, 표준이 아닌 순서로 비교하고 싶은 경우 Comparator를 사용한다.\n요약 순서를 고려할 수 있는 값 객체를 만드는 경우 Comparable을 구현하면 컬렉션의 강력한 여러 기능들을 이용할 수 있게 된다.\n","permalink":"https://junbread.win/posts/2021/effective-java-03/","summary":"아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.\n각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.\n반사성: A.equals(A)가 참이다\n대칭성: A.equals(B)가 참이라면 B.equals(A)이다\npublic class Point { @Override boolean equals(Object o) { if (!","title":"이펙티브 자바 3장 정리"},{"content":"가장 널리 쓰이는 리눅스 셸. 많은 배포판에서 기본 셸로 지정되어 있다. fish와 zsh도 사용해 봤지만, 가볍고 범용적인 bash로 결국 돌아오게 된다.\nCheetsheet 직접적으로 Bash와 관련 없지만 터미널 전반적인 명령어 사용법도 함께 수록한다.\ncd -: 직전 히스토리로 돌아가기 !!: 직전 사용 명령어. sudo !! 식으로 사용하면 깜빡하고 sudo를 붙이지 않은 명령어를 다시 입력할 필요가 없다. 사용 노하우 여러 환경에서 일관되게 .bashrc 관리하기 ~/.bashrc는 여러 가지 bash 설정을 기입해 놓은 파일이다. 다른 설정을 수정하지 않았을 경우 여기서 설정을 로드한다.\n나는 설정 파일을 dotfiles 저장소에 올려놓고 관리 중이다. 새롭게 linux 환경을 설치한 경우 홈 디렉토리에 해당 저장소를 clone하고 설정 파일을 심볼릭 링크하면 되므로 굉장히 편리하다.\nBash Prompt 두 줄로 만들기 다음과 같이 PS1 변수에 줄바꿈을 넣어 주면 된다. Raw string이므로 들여쓰기하지 않아야 한다.\nPS1=\u0026#39;${debian_chroot:+($debian_chroot)}\\h:\\w \\$ \u0026#39; 자세한 설정은 이 파일을 참고하면 된다.\n","permalink":"https://junbread.win/posts/2021/bash/","summary":"가장 널리 쓰이는 리눅스 셸. 많은 배포판에서 기본 셸로 지정되어 있다. fish와 zsh도 사용해 봤지만, 가볍고 범용적인 bash로 결국 돌아오게 된다.\nCheetsheet 직접적으로 Bash와 관련 없지만 터미널 전반적인 명령어 사용법도 함께 수록한다.\ncd -: 직전 히스토리로 돌아가기 !!: 직전 사용 명령어. sudo !! 식으로 사용하면 깜빡하고 sudo를 붙이지 않은 명령어를 다시 입력할 필요가 없다. 사용 노하우 여러 환경에서 일관되게 .bashrc 관리하기 ~/.bashrc는 여러 가지 bash 설정을 기입해 놓은 파일이다. 다른 설정을 수정하지 않았을 경우 여기서 설정을 로드한다.","title":"Bash"},{"content":"IPA furigana 웹페이지에 있는 한자 단어에 후리가나를 달아 주는 확장\nVimium vim-like 키매핑으로 웹서핑을 가능하게 해 주는 확장\nf 키가 꿀 기능이다.\nQuick QR Code Generator 보고 있는 페이지 URL을 QR 코드로 만들어 주는 확장\nWindows-iOS 간 히스토리 공유가 안 되어서.. PC에서 보던거 폰으로 옮기고 싶을 때 가끔 사용\n최신 버전 크로미움의 경우 브라우저에서 자체적으로 이 기능을 지원해 주기 시작한 것 같다.\n이 링크에서 활성화 가능\n","permalink":"https://junbread.win/posts/2021/chrome-extension-recommendation/","summary":"IPA furigana 웹페이지에 있는 한자 단어에 후리가나를 달아 주는 확장\nVimium vim-like 키매핑으로 웹서핑을 가능하게 해 주는 확장\nf 키가 꿀 기능이다.\nQuick QR Code Generator 보고 있는 페이지 URL을 QR 코드로 만들어 주는 확장\nWindows-iOS 간 히스토리 공유가 안 되어서.. PC에서 보던거 폰으로 옮기고 싶을 때 가끔 사용\n최신 버전 크로미움의 경우 브라우저에서 자체적으로 이 기능을 지원해 주기 시작한 것 같다.\n이 링크에서 활성화 가능","title":"Chrome 확장기능 추천목록"},{"content":"마이크로소프트에서 개발한 강력한 텍스트 에디터. Electron 기반으로 만들어졌다.\n사용하고 있는 플러그인 Shell launcher VS Code에 임베드되어 있는 터미널 패널은 기본 셸 환경을 바꿀 수 있도록 되어 있지만, 상황별로 다른 셸을 사용하고자 할 때는 불편하다. Shell launcher 플러그인은 현재 설치되어 있는 셸을 자동으로 인식해 리스트에 표시해 준다. 간단하지만 편리하다.\nRender Line Endings Windows 머신에 WSL을 설치해 사용하고 있다. 한 가지 문제는 Windows와 Linux의 EOL 처리가 서로 달라서 충돌이 일어나는 경우가 있다는 것이다. CRLF로 처리된 셸 스크립트 파일을 WSL 환경에서 실행할 경우 오류가 일어나거나, Git에서 파일 내용은 변경되지 않았는데 CR이 추가되어 변경된 파일로 표시된다거나 하는 다양한 문제가 있다. VS Code는 기본적으로 EOL을 인식해서 오른쪽 하단에 표시해 주지만, 개별 문자는 표시하지 않는다. 이 플러그인을 설치하면 CRLF와 LF을 렌더링해 주기 때문에 편리하게 디버깅이 가능하다.\nvscode-pdf VS Code에서 PDF를 볼 수 있는 플러그인. PDF 뷰어를 별도로 띄우고 싶지 않을 때 유용하다.\n재시작했을 때 뷰가 다시 로드되지 않는 단점이 있다.\n","permalink":"https://junbread.win/posts/2021/vs-code/","summary":"마이크로소프트에서 개발한 강력한 텍스트 에디터. Electron 기반으로 만들어졌다.\n사용하고 있는 플러그인 Shell launcher VS Code에 임베드되어 있는 터미널 패널은 기본 셸 환경을 바꿀 수 있도록 되어 있지만, 상황별로 다른 셸을 사용하고자 할 때는 불편하다. Shell launcher 플러그인은 현재 설치되어 있는 셸을 자동으로 인식해 리스트에 표시해 준다. 간단하지만 편리하다.\nRender Line Endings Windows 머신에 WSL을 설치해 사용하고 있다. 한 가지 문제는 Windows와 Linux의 EOL 처리가 서로 달라서 충돌이 일어나는 경우가 있다는 것이다.","title":"VS Code"},{"content":"Windows 환경에서 유용하게 사용할 수 있는 유틸리티 모음\nLittleBigMouse 멀티 모니터 마우스 스케일링 유틸리티\n멀티 모니터 사용 시 DPI 차이에 따른 마우스 위치 어긋남 등을 조정해 주는 유틸리티\nDPI 스케일링뿐만 아니라 모니터 위치 정밀 조정 등 여러가지 편리한 기능이 들어가 있다\nmgth/LittleBigMouse\nChocolatey Windows 커맨드라인 패키지 매니저\nbrew, apt 등과 같은 기능을 제공한다. 웬만한 패키지는 다 있음\n비슷한 걸로 scoop, winget 등이 있는데, scoop은 유저스페이스에만 설치가 가능하고 winget은 아직 개발중이라 별로\nChocolatey - The package manager for Windows\nTwinkle Tray 모니터 밝기 조절 유틸리티\n데스크탑에서 하드웨어 버튼을 안 건드리고도 모니터 밝기 조절을 할 수 있다\nTwinkle Tray - Windows 10 Brightness Slider\nWindows Terminal 통합 터미널 에뮬레이터\nWSL과 통합도 가능하고 간편하게 사용 가능해서 주력 터미널 에뮬레이터로 사용중\n잘 설정하면 앱 실행시 바로 원하는 SSH 세션을 띄울 수도 있다\nWindows Terminal 구매 - Microsoft Store ko-KR\nPowerToys 강력한 유틸리티 모음집\n마소에서 개발하는 각종 트윅 및 추가기능 꾸러미. 아직 프리뷰 버전이라 개발 페이지에서 다운받아야 함\n가장 유용한 기능은 FancyZones인데 화면분할 레이아웃을 원하는 대로 다양하게 꾸밀 수 있음\n이외에도 기능키 매핑, 이미지 자동 리사이저, Windows판 Spotlight 등 여러가지 기능을 제공중\nmicrosoft/PowerToys\n","permalink":"https://junbread.win/posts/2021/windows-utility-recommendation/","summary":"Windows 환경에서 유용하게 사용할 수 있는 유틸리티 모음\nLittleBigMouse 멀티 모니터 마우스 스케일링 유틸리티\n멀티 모니터 사용 시 DPI 차이에 따른 마우스 위치 어긋남 등을 조정해 주는 유틸리티\nDPI 스케일링뿐만 아니라 모니터 위치 정밀 조정 등 여러가지 편리한 기능이 들어가 있다\nmgth/LittleBigMouse\nChocolatey Windows 커맨드라인 패키지 매니저\nbrew, apt 등과 같은 기능을 제공한다. 웬만한 패키지는 다 있음\n비슷한 걸로 scoop, winget 등이 있는데, scoop은 유저스페이스에만 설치가 가능하고 winget은 아직 개발중이라 별로","title":"Windows 유틸리티 추천목록"},{"content":" Windows Subsystem for Linux\n개요 Windows에서 리눅스를 구동할 수 있게 해 준다. WSL 1은 리눅스 시스템 콜을 Windows 시스템 콜로 번역하는 식으로 이루어졌지만 WSL 2부터는 Hyper-V를 이용해 구동된다.\n설치 WSL 1의 경우 Windows 10 Pro 에디션 이상이 필요하다. WSL 2부터는 Windows 10 Home 에디션에서도 이용할 수 있게 되었다.\nMicrosoft Docs에 자세한 설치 과정이 안내되어 있다.\n팁과 주의사항 Hyper-V 사용시 퍼포먼스 하락 WSL 2는 Hyper-V를 사용하기 때문에 설치 전 Hyper-V 기능을 사용 설정해야 한다. 이 경우 호스트 OS인 Windows도 가상화 계층 위에서 실행되도록 변경되기 때문에 성능 하락이 있을 수 있다. 참고\nWSL 2에서 Windows 파티션 사용시 퍼포먼스 저하 관련 GitHub 이슈\nWSL 2에서 /mnt 아래에 마운트된 파티션을 사용할 경우 I/O 성능이 매우 떨어지는 현상이 있다. 거의 1/10 정도로 큰 성능 저하가 일어나므로 사용에 주의해야 한다. WSL 2가 VM 기반으로 변경되면서 호스트 OS와의 통신 문제로 발생한 듯 한데 매우 큰 문제인 듯하다. / 아래의 WSL 파티션을 이용할 경우에는 괜찮다.\n여러 모로 WSL 2가 아직 릴리즈하기 어려운 상태임에도 불구하고 무리하게 출시하는 듯한 느낌이다.\n","permalink":"https://junbread.win/posts/2021/wsl/","summary":"Windows Subsystem for Linux\n개요 Windows에서 리눅스를 구동할 수 있게 해 준다. WSL 1은 리눅스 시스템 콜을 Windows 시스템 콜로 번역하는 식으로 이루어졌지만 WSL 2부터는 Hyper-V를 이용해 구동된다.\n설치 WSL 1의 경우 Windows 10 Pro 에디션 이상이 필요하다. WSL 2부터는 Windows 10 Home 에디션에서도 이용할 수 있게 되었다.\nMicrosoft Docs에 자세한 설치 과정이 안내되어 있다.\n팁과 주의사항 Hyper-V 사용시 퍼포먼스 하락 WSL 2는 Hyper-V를 사용하기 때문에 설치 전 Hyper-V 기능을 사용 설정해야 한다.","title":"WSL"},{"content":" ✉️ Mail\n🔐 Keybase\n👩🏻‍💻 GitHub\n🔗 LinkedIn\n안녕하세요, 김준현입니다. Java를 메인으로 이것저것 개발하고 있습니다. 잘 부탁드립니다.\n2020.12 ~ now 네이버 (Forest CIC) 쇼핑라이브 서비스 백엔드 개발 키워드 Spring Boot Kafka ElasticSearch HDFS 2020.07 ~ 2020.08 삼성전자 (CE/IM사업부) 대학생 인턴십 TV 보이스 어시스턴트 자동화 툴 제작 2016.11 ~ 2018.11 공군정보체계관리단 S/W유지보수병 (의무복무) 인트라넷 웹 서비스 개발 및 유지보수 2014.03 ~ 2021.02 성균관대학교 컴퓨터공학과 학사 ","permalink":"https://junbread.win/about/","summary":" ✉️ Mail\n🔐 Keybase\n👩🏻‍💻 GitHub\n🔗 LinkedIn\n안녕하세요, 김준현입니다. Java를 메인으로 이것저것 개발하고 있습니다. 잘 부탁드립니다.\n2020.12 ~ now 네이버 (Forest CIC) 쇼핑라이브 서비스 백엔드 개발 키워드 Spring Boot Kafka ElasticSearch HDFS 2020.07 ~ 2020.08 삼성전자 (CE/IM사업부) 대학생 인턴십 TV 보이스 어시스턴트 자동화 툴 제작 2016.11 ~ 2018.11 공군정보체계관리단 S/W유지보수병 (의무복무) 인트라넷 웹 서비스 개발 및 유지보수 2014.03 ~ 2021.02 성균관대학교 컴퓨터공학과 학사 ","title":"About"}]