<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>이펙티브 자바 3장 정리 | Junbread🥐</title><meta name=keywords content="Study,Java"><meta name=description content="아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.
각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.
반사성: A.equals(A)가 참이다
대칭성: A.equals(B)가 참이라면 B.equals(A)이다
public class Point { @Override boolean equals(Object o) { if (!"><meta name=author content><link rel=canonical href=https://junbread.win/posts/2021/effective-java-03/><link crossorigin=anonymous href=/assets/css/stylesheet.f6c1b3e9443ffcf8efd37433e13b909fd545f99414f2ac3e5b22795096fc9f44.css integrity="sha256-9sGz6UQ//Pjv03Qz4TuQn9VF+ZQU8qw+WyJ5UJb8n0Q=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://junbread.win/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junbread.win/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junbread.win/favicon-32x32.png><link rel=apple-touch-icon href=https://junbread.win/apple-touch-icon.png><link rel=mask-icon href=https://junbread.win/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet type=text/css crossorigin href=//cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/variable/pretendardvariable-dynamic-subset.css><link rel=stylesheet type=text/css crossorigin href="//fonts.googleapis.com/css2?family=Source+Code+Pro"><script async src="https://www.googletagmanager.com/gtag/js?id=G-0QLLXH086F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0QLLXH086F",{anonymize_ip:!1})}</script><meta property="og:title" content="이펙티브 자바 3장 정리"><meta property="og:description" content="아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.
각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.
반사성: A.equals(A)가 참이다
대칭성: A.equals(B)가 참이라면 B.equals(A)이다
public class Point { @Override boolean equals(Object o) { if (!"><meta property="og:type" content="article"><meta property="og:url" content="https://junbread.win/posts/2021/effective-java-03/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-23T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="이펙티브 자바 3장 정리"><meta name=twitter:description content="아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.
각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.
반사성: A.equals(A)가 참이다
대칭성: A.equals(B)가 참이라면 B.equals(A)이다
public class Point { @Override boolean equals(Object o) { if (!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://junbread.win/posts/"},{"@type":"ListItem","position":3,"name":"이펙티브 자바 3장 정리","item":"https://junbread.win/posts/2021/effective-java-03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"이펙티브 자바 3장 정리","name":"이펙티브 자바 3장 정리","description":"아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.\n각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.\n반사성: A.equals(A)가 참이다\n대칭성: A.equals(B)가 참이라면 B.equals(A)이다\npublic class Point { @Override boolean equals(Object o) { if (!","keywords":["Study","Java"],"articleBody":"아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.\n각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.\n반사성: A.equals(A)가 참이다\n대칭성: A.equals(B)가 참이라면 B.equals(A)이다\npublic class Point { @Override boolean equals(Object o) { if (!(o instanceof Point)) return false; return ((Point) o).xxx == xxx; } } public class ColorPoint { @Override boolean equals(Object o) { if (!(o instanceof ColorPoint)) return false; return ((ColorPoint) o).xxx == xxx \u0026\u0026 ((ColorPoint) o).yyy == yyy; } } 추이성: A.equals(B)이고 B.equals(C)이면 A.equals(C)이다\n구체 클래스를 확장하면서 동치 관계를 만족시킬 방법은 없다.\n→ 상속 대신 컴포지션을 사용하자.\n일관성: A.equals(B)의 결과는 언제나 같아야 한다\nequals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안 된다. equals에 네트워크를 통한 검사 로직이 들어 있다면? (null-아님): 모든 객체는 null과 같지 않다\n일반적인 equals 구현 방법 == 연산자로 자기 자신의 참조인지 확인 instanceof로 입력이 올바른 타입인지 확인 올바른 타입으로 캐스팅 핵심 필드들이 일치하는지 하나하나 검사 비교 비용이 낮은 필드부터 비교하기 요약 꼭 필요한 경우가 아니면 equals를 재정의하지 않는 것이 좋다. equals 재정의를 할 때에는 반사성, 대칭성, 추이성, 일관성, (null-아님)의 다섯 가지 규칙을 반드시 지켜야 한다.\n아이템 11: equals를 재정의하려거든 hashCode도 재정의하라 hashCode를 재정의하지 않을 경우 애플리케이션 동작에 이상을 일으킬 수 있다.\nhashCode에 관한 규약 equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.\nequals 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.\nequals 메서드가 다르다고 판단한 두 객체의 hashCode 값이 꼭 다를 필요는 없다.\n→ 그러나 서로 다른 hashCode 값이 나오면 해시 테이블의 성능이 향상될 수 있다.\nhashCode 구현시 주의사항 해시코드 계산에 핵심 필드가 빠지게 되면 해시 함수의 성능이 크게 감소할 수 있다. Lombok의 @EqualsAndHashCode 를 이용하면 일관적으로 equals와 hashCode 메서드를 재정의할 수 있다.\n요약 equals 재정의 시에는 hashCode를 항상 함께 재정의해야 한다.\n아이템 12: toString을 항상 제공하라 toString은 직접 사용하지 않더라도 디버거, 객체 직렬화 등 많은 곳에서 사용되므로 재정의하는 것이 좋다.\n좋은 toString 만들기 toString에는 가급적 클래스의 핵심 정보를 모두 제공해야 한다.\n주석으로 의도를 명확하게 밝히는 것이 좋다.\ntoString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공해야 한다.\n→ 그렇지 않으면 사실상 toString이 접근자 역할을 하게 되고, toString을 파싱하는 시도를 하게 된다.\n역시 Lombok의 @ToString을 이용하면 간편하게 toString을 재정의할 수 있다.\n요약 toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.\n아이템 13: clone 재정의는 주의해서 진행하라 clone의 명세는 허술하다 Cloneable은 아무런 메서드를 가지지 않는 인터페이스이지만, clone의 동작 방식을 결정한다. Object.clone()은 checked exception을 던지기 때문에 사용하기 불편하다. clone 메서드를 제대로 구현했는지 시스템적으로 검증할 방법이 없다. super.clone()을 호출했는지, 생성자를 호출했는지 컴파일러는 상관하지 않는다. clone 재정의 시 주의사항 clone 메소드는 사실상 생성자와 같은 효과를 낸다. 즉 clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다. 클래스가 가변 객체를 참조한다면 원본과 복제본이 가변 객체를 공유해도 되는지 확인하고, 깊은 복사를 구현해야 한다. 클래스가 Thread-safe하다면 clone 재정의 시에도 동기화에 신경써야 한다. Cloneable을 구현하는 클래스는 clone을 재정의해야 한다. 이 때 접근제어자를 public으로 바꾸고, 반환 타입을 클래스 자신으로 바꾸고, throws 절도 없애는 것이 좋다. 상속용 클래스는 Cloneable을 구현하게 하면 안 된다. 하위 클래스에서 clone을 지원할지 선택하게 하자. 복사 생성자와 복사 팩터리 자기 자신을 인수로 받는 생성자나, 유사한 방식의 정적 팩토리 메서드를 사용하면 clone의 단점이었던 허술한 스펙, final용법과 충돌, 불필요한 checked exception, 형변환 등을 해결할 수 있다.\npublic Point(Point point) { ... } public static Point newInstance(Point point) { ... } 요약 Cloneable 인터페이스와 clone은 허술하게 설계되어 있기 때문에 많은 문제를 내포하고 있다. 가급적 복사 생성자 방식을 사용하자.\n아이템 14: Comparable을 구현할지 고려하라 compareTo의 특징과 규칙 compareTo 메소드는 Object가 아닌 Comparable 인터페이스에 있다. compareTo 는 제네릭이고, 순서뿐 아니라 동치성도 비교할 수 있다. compareTo 메소드의 일반 규칙과 주의사항은 equals 규칙과 비슷하다. 반사성, 대칭성, 추이성을 충족해야 한다. (권장) compareTo를 이용한 동치성 테스트는 equals 결과와 같아야 한다. 구체 클래스를 확장한 경우 compareTo의 규칙을 지킬 수 없으며, 컴포지션으로 우회한다. compareTo 메서드 구현 시의 주의사항 기본 타입 클래스를 비교할 때도 가급적 박싱된 기본 타입 클래스에 추가된 compare 메서드를 이용하자. 값의 차를 기준으로 compareTo를 구현하는 경우 오버플로우, 부동소수점 오류 등 예상치 않은 결과를 낼 수 있다. Comparable을 구현하지 않은 클래스를 비교하거나, 표준이 아닌 순서로 비교하고 싶은 경우 Comparator를 사용한다.\n요약 순서를 고려할 수 있는 값 객체를 만드는 경우 Comparable을 구현하면 컬렉션의 강력한 여러 기능들을 이용할 수 있게 된다.\n","wordCount":"721","inLanguage":"en","datePublished":"2021-03-23T00:00:00Z","dateModified":"2021-03-23T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://junbread.win/posts/2021/effective-java-03/"},"publisher":{"@type":"Organization","name":"Junbread🥐","logo":{"@type":"ImageObject","url":"https://junbread.win/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junbread.win accesskey=h title="Junbread🥐 (Alt + H)">Junbread🥐</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://junbread.win/about title=About><span>About</span></a></li><li><a href=https://junbread.win/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://junbread.win/tags/ title=태그><span>태그</span></a></li><li><a href=https://junbread.win/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://junbread.win>Home</a>&nbsp;»&nbsp;<a href=https://junbread.win/posts/>Posts</a></div><h1 class=post-title>이펙티브 자바 3장 정리</h1><div class=post-meta><span title='2021-03-23 00:00:00 +0000 UTC'>March 23, 2021</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-10-equals%eb%8a%94-%ec%9d%bc%eb%b0%98-%ea%b7%9c%ec%95%bd%ec%9d%84-%ec%a7%80%ec%bc%9c-%ec%9e%ac%ec%a0%95%ec%9d%98%ed%95%98%eb%9d%bc aria-label="아이템 10: equals는 일반 규약을 지켜 재정의하라">아이템 10: equals는 일반 규약을 지켜 재정의하라</a><ul><li><a href=#equals%eb%8a%94-%ec%96%b8%ec%a0%9c-%ec%9e%ac%ec%a0%95%ec%9d%98%ed%95%b4%ec%95%bc-%ed%95%a0%ea%b9%8c aria-label="equals는 언제 재정의해야 할까?">equals는 언제 재정의해야 할까?</a></li><li><a href=#equals%ea%b0%80-%eb%a7%8c%ec%a1%b1%ec%8b%9c%ec%bc%9c%ec%95%bc-%ed%95%98%eb%8a%94-%ec%a1%b0%ea%b1%b4 aria-label="equals가 만족시켜야 하는 조건">equals가 만족시켜야 하는 조건</a></li><li><a href=#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-equals-%ea%b5%ac%ed%98%84-%eb%b0%a9%eb%b2%95 aria-label="일반적인 equals 구현 방법">일반적인 equals 구현 방법</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-11-equals%eb%a5%bc-%ec%9e%ac%ec%a0%95%ec%9d%98%ed%95%98%eb%a0%a4%ea%b1%b0%eb%93%a0-hashcode%eb%8f%84-%ec%9e%ac%ec%a0%95%ec%9d%98%ed%95%98%eb%9d%bc aria-label="아이템 11: equals를 재정의하려거든 hashCode도 재정의하라">아이템 11: equals를 재정의하려거든 hashCode도 재정의하라</a><ul><li><a href=#hashcode%ec%97%90-%ea%b4%80%ed%95%9c-%ea%b7%9c%ec%95%bd aria-label="hashCode에 관한 규약">hashCode에 관한 규약</a></li><li><a href=#hashcode-%ea%b5%ac%ed%98%84%ec%8b%9c-%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad aria-label="hashCode 구현시 주의사항">hashCode 구현시 주의사항</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-12-tostring%ec%9d%84-%ed%95%ad%ec%83%81-%ec%a0%9c%ea%b3%b5%ed%95%98%eb%9d%bc aria-label="아이템 12: toString을 항상 제공하라">아이템 12: toString을 항상 제공하라</a><ul><li><a href=#%ec%a2%8b%ec%9d%80-tostring-%eb%a7%8c%eb%93%a4%ea%b8%b0 aria-label="좋은 toString 만들기">좋은 toString 만들기</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-13-clone-%ec%9e%ac%ec%a0%95%ec%9d%98%eb%8a%94-%ec%a3%bc%ec%9d%98%ed%95%b4%ec%84%9c-%ec%a7%84%ed%96%89%ed%95%98%eb%9d%bc aria-label="아이템 13: clone 재정의는 주의해서 진행하라">아이템 13: clone 재정의는 주의해서 진행하라</a><ul><li><a href=#clone%ec%9d%98-%eb%aa%85%ec%84%b8%eb%8a%94-%ed%97%88%ec%88%a0%ed%95%98%eb%8b%a4 aria-label="clone의 명세는 허술하다">clone의 명세는 허술하다</a></li><li><a href=#clone-%ec%9e%ac%ec%a0%95%ec%9d%98-%ec%8b%9c-%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad aria-label="clone 재정의 시 주의사항"><code>clone</code> 재정의 시 주의사항</a></li><li><a href=#%eb%b3%b5%ec%82%ac-%ec%83%9d%ec%84%b1%ec%9e%90%ec%99%80-%eb%b3%b5%ec%82%ac-%ed%8c%a9%ed%84%b0%eb%a6%ac aria-label="복사 생성자와 복사 팩터리">복사 생성자와 복사 팩터리</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-14-comparable%ec%9d%84-%ea%b5%ac%ed%98%84%ed%95%a0%ec%a7%80-%ea%b3%a0%eb%a0%a4%ed%95%98%eb%9d%bc aria-label="아이템 14: Comparable을 구현할지 고려하라">아이템 14: Comparable을 구현할지 고려하라</a><ul><li><a href=#compareto%ec%9d%98-%ed%8a%b9%ec%a7%95%ea%b3%bc-%ea%b7%9c%ec%b9%99 aria-label="compareTo의 특징과 규칙">compareTo의 특징과 규칙</a></li><li><a href=#compareto-%eb%a9%94%ec%84%9c%eb%93%9c-%ea%b5%ac%ed%98%84-%ec%8b%9c%ec%9d%98-%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad aria-label="compareTo 메서드 구현 시의 주의사항">compareTo 메서드 구현 시의 주의사항</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=아이템-10-equals는-일반-규약을-지켜-재정의하라>아이템 10: equals는 일반 규약을 지켜 재정의하라<a hidden class=anchor aria-hidden=true href=#아이템-10-equals는-일반-규약을-지켜-재정의하라>#</a></h2><h3 id=equals는-언제-재정의해야-할까>equals는 언제 재정의해야 할까?<a hidden class=anchor aria-hidden=true href=#equals는-언제-재정의해야-할까>#</a></h3><p>클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.</p><ul><li>각 인스턴스가 본질적으로 고유하다</li><li>인스턴스의 논리적 동치성을 검사할 일이 없다</li><li>상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다</li><li>클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다</li></ul><h3 id=equals가-만족시켜야-하는-조건>equals가 만족시켜야 하는 조건<a hidden class=anchor aria-hidden=true href=#equals가-만족시켜야-하는-조건>#</a></h3><p>equals는 다음 다섯 가지 조건을 만족해야 한다.</p><ul><li><p>반사성: <code>A.equals(A)가 참이다</code></p></li><li><p>대칭성: <code>A.equals(B)가 참이라면 B.equals(A)이다</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>Object o<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#f92672>(!(</span>o <span style=color:#66d9ef>instanceof</span> Point<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>((</span>Point<span style=color:#f92672>)</span> o<span style=color:#f92672>).</span><span style=color:#a6e22e>xxx</span> <span style=color:#f92672>==</span> xxx<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ColorPoint</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>Object o<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#f92672>(!(</span>o <span style=color:#66d9ef>instanceof</span> ColorPoint<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>((</span>ColorPoint<span style=color:#f92672>)</span> o<span style=color:#f92672>).</span><span style=color:#a6e22e>xxx</span> <span style=color:#f92672>==</span> xxx <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>((</span>ColorPoint<span style=color:#f92672>)</span> o<span style=color:#f92672>).</span><span style=color:#a6e22e>yyy</span> <span style=color:#f92672>==</span> yyy<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></li><li><p>추이성: <code>A.equals(B)이고 B.equals(C)이면 A.equals(C)이다</code></p><ul><li><p><strong>구체 클래스를 확장하면서 동치 관계를 만족시킬 방법은 없다.</strong></p><p>→ 상속 대신 컴포지션을 사용하자.</p></li></ul></li><li><p>일관성: <code>A.equals(B)의 결과는 언제나 같아야 한다</code></p><ul><li>equals의 판단에 신뢰할 수 없는 자원이 끼어들어서는 안 된다.
equals에 네트워크를 통한 검사 로직이 들어 있다면?</li></ul></li><li><p>(null-아님): <code>모든 객체는 null과 같지 않다</code></p></li></ul><h3 id=일반적인-equals-구현-방법>일반적인 equals 구현 방법<a hidden class=anchor aria-hidden=true href=#일반적인-equals-구현-방법>#</a></h3><ul><li><code>==</code> 연산자로 자기 자신의 참조인지 확인</li><li><code>instanceof</code>로 입력이 올바른 타입인지 확인</li><li>올바른 타입으로 캐스팅</li><li>핵심 필드들이 일치하는지 하나하나 검사<ul><li>비교 비용이 <strong>낮은 필드</strong>부터 비교하기</li></ul></li></ul><blockquote><p><code>요약</code> 꼭 필요한 경우가 아니면 equals를 재정의하지 않는 것이 좋다. equals 재정의를 할 때에는 반사성, 대칭성, 추이성, 일관성, (null-아님)의 다섯 가지 규칙을 반드시 지켜야 한다.</p></blockquote><h2 id=아이템-11-equals를-재정의하려거든-hashcode도-재정의하라>아이템 11: equals를 재정의하려거든 hashCode도 재정의하라<a hidden class=anchor aria-hidden=true href=#아이템-11-equals를-재정의하려거든-hashcode도-재정의하라>#</a></h2><p>hashCode를 재정의하지 않을 경우 애플리케이션 동작에 이상을 일으킬 수 있다.</p><h3 id=hashcode에-관한-규약>hashCode에 관한 규약<a hidden class=anchor aria-hidden=true href=#hashcode에-관한-규약>#</a></h3><ul><li><p>equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.</p></li><li><p>equals 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.</p></li><li><p>equals 메서드가 다르다고 판단한 두 객체의 hashCode 값이 꼭 다를 필요는 없다.</p><p>→ 그러나 서로 다른 hashCode 값이 나오면 해시 테이블의 성능이 향상될 수 있다.</p></li></ul><h3 id=hashcode-구현시-주의사항>hashCode 구현시 주의사항<a hidden class=anchor aria-hidden=true href=#hashcode-구현시-주의사항>#</a></h3><ul><li>해시코드 계산에 핵심 필드가 빠지게 되면 해시 함수의 성능이 크게 감소할 수 있다.</li></ul><p>Lombok의 <code>@EqualsAndHashCode</code> 를 이용하면 일관적으로 equals와 hashCode 메서드를 재정의할 수 있다.</p><blockquote><p><code>요약</code> equals 재정의 시에는 hashCode를 항상 함께 재정의해야 한다.</p></blockquote><h2 id=아이템-12-tostring을-항상-제공하라>아이템 12: toString을 항상 제공하라<a hidden class=anchor aria-hidden=true href=#아이템-12-tostring을-항상-제공하라>#</a></h2><p>toString은 직접 사용하지 않더라도 디버거, 객체 직렬화 등 많은 곳에서 사용되므로 재정의하는 것이 좋다.</p><h3 id=좋은-tostring-만들기>좋은 toString 만들기<a hidden class=anchor aria-hidden=true href=#좋은-tostring-만들기>#</a></h3><ul><li><p>toString에는 가급적 클래스의 핵심 정보를 모두 제공해야 한다.</p></li><li><p>주석으로 의도를 명확하게 밝히는 것이 좋다.</p></li><li><p>toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공해야 한다.</p><p>→ 그렇지 않으면 사실상 toString이 접근자 역할을 하게 되고, toString을 파싱하는 시도를 하게 된다.</p></li></ul><p>역시 Lombok의 <code>@ToString</code>을 이용하면 간편하게 toString을 재정의할 수 있다.</p><blockquote><p><code>요약</code> toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.</p></blockquote><h2 id=아이템-13-clone-재정의는-주의해서-진행하라>아이템 13: clone 재정의는 주의해서 진행하라<a hidden class=anchor aria-hidden=true href=#아이템-13-clone-재정의는-주의해서-진행하라>#</a></h2><h3 id=clone의-명세는-허술하다>clone의 명세는 허술하다<a hidden class=anchor aria-hidden=true href=#clone의-명세는-허술하다>#</a></h3><ul><li><code>Cloneable</code>은 아무런 메서드를 가지지 않는 인터페이스이지만, clone의 동작 방식을 결정한다.</li><li><code>Object.clone()</code>은 checked exception을 던지기 때문에 사용하기 불편하다.</li><li>clone 메서드를 제대로 구현했는지 시스템적으로 검증할 방법이 없다.<ul><li><code>super.clone()</code>을 호출했는지, 생성자를 호출했는지 컴파일러는 상관하지 않는다.</li></ul></li></ul><h3 id=clone-재정의-시-주의사항><code>clone</code> 재정의 시 주의사항<a hidden class=anchor aria-hidden=true href=#clone-재정의-시-주의사항>#</a></h3><ul><li>clone 메소드는 사실상 생성자와 같은 효과를 낸다. 즉 clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.<ul><li>클래스가 가변 객체를 참조한다면 원본과 복제본이 가변 객체를 공유해도 되는지 확인하고, 깊은 복사를 구현해야 한다.</li></ul></li><li>클래스가 Thread-safe하다면 clone 재정의 시에도 동기화에 신경써야 한다.</li><li>Cloneable을 구현하는 클래스는 clone을 재정의해야 한다. 이 때 접근제어자를 public으로 바꾸고, 반환 타입을 클래스 자신으로 바꾸고, throws 절도 없애는 것이 좋다.</li><li>상속용 클래스는 Cloneable을 구현하게 하면 안 된다. 하위 클래스에서 clone을 지원할지 선택하게 하자.</li></ul><h3 id=복사-생성자와-복사-팩터리>복사 생성자와 복사 팩터리<a hidden class=anchor aria-hidden=true href=#복사-생성자와-복사-팩터리>#</a></h3><p>자기 자신을 인수로 받는 생성자나, 유사한 방식의 정적 팩토리 메서드를 사용하면 clone의 단점이었던 허술한 스펙, final용법과 충돌, 불필요한 checked exception, 형변환 등을 해결할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Point</span>(<span style=color:#a6e22e>Point</span> <span style=color:#a6e22e>point</span>) { ... }
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>Point</span> <span style=color:#a6e22e>newInstance</span>(<span style=color:#a6e22e>Point</span> <span style=color:#a6e22e>point</span>) { ... }
</span></span></code></pre></div><blockquote><p><code>요약</code> Cloneable 인터페이스와 clone은 허술하게 설계되어 있기 때문에 많은 문제를 내포하고 있다. 가급적 복사 생성자 방식을 사용하자.</p></blockquote><h2 id=아이템-14-comparable을-구현할지-고려하라>아이템 14: Comparable을 구현할지 고려하라<a hidden class=anchor aria-hidden=true href=#아이템-14-comparable을-구현할지-고려하라>#</a></h2><h3 id=compareto의-특징과-규칙>compareTo의 특징과 규칙<a hidden class=anchor aria-hidden=true href=#compareto의-특징과-규칙>#</a></h3><ul><li>compareTo 메소드는 Object가 아닌 Comparable 인터페이스에 있다.</li><li>compareTo 는 제네릭이고, 순서뿐 아니라 동치성도 비교할 수 있다.</li><li>compareTo 메소드의 일반 규칙과 주의사항은 equals 규칙과 비슷하다.<ul><li>반사성, 대칭성, 추이성을 충족해야 한다.</li><li>(권장) compareTo를 이용한 동치성 테스트는 equals 결과와 같아야 한다.</li><li>구체 클래스를 확장한 경우 compareTo의 규칙을 지킬 수 없으며, 컴포지션으로 우회한다.</li></ul></li></ul><h3 id=compareto-메서드-구현-시의-주의사항>compareTo 메서드 구현 시의 주의사항<a hidden class=anchor aria-hidden=true href=#compareto-메서드-구현-시의-주의사항>#</a></h3><ul><li>기본 타입 클래스를 비교할 때도 가급적 박싱된 기본 타입 클래스에 추가된 compare 메서드를 이용하자.</li><li>값의 차를 기준으로 compareTo를 구현하는 경우 오버플로우, 부동소수점 오류 등 예상치 않은 결과를 낼 수 있다.</li></ul><p>Comparable을 구현하지 않은 클래스를 비교하거나, 표준이 아닌 순서로 비교하고 싶은 경우 Comparator를 사용한다.</p><blockquote><p><code>요약</code> 순서를 고려할 수 있는 값 객체를 만드는 경우 Comparable을 구현하면 컬렉션의 강력한 여러 기능들을 이용할 수 있게 된다.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://junbread.win/tags/study/>Study</a></li><li><a href=https://junbread.win/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://junbread.win/posts/2021/effective-java-04/><span class=title>« Prev</span><br><span>이펙티브 자바 4장 정리</span></a>
<a class=next href=https://junbread.win/posts/2021/bash/><span class=title>Next »</span><br><span>Bash</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=junbread/blog data-repo-id=R_kgDOJLcBtQ data-category=Comments data-category-id=DIC_kwDOJLcBtc4CVATm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=dark data-lang=ko data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://junbread.win>Junbread🥐</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>