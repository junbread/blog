<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>이펙티브 자바 5장 정리 | Junbread🥐</title><meta name=keywords content="Study,Java"><meta name=description content="제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.
아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.
→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.
public class Raw { public static void main(String[] args) { List<String> strings = new ArrayList<>(); unsafeAdd(strings, Integer."><meta name=author content><link rel=canonical href=https://junbread.win/posts/2021/effective-java-05/><link crossorigin=anonymous href=/assets/css/stylesheet.f6c1b3e9443ffcf8efd37433e13b909fd545f99414f2ac3e5b22795096fc9f44.css integrity="sha256-9sGz6UQ//Pjv03Qz4TuQn9VF+ZQU8qw+WyJ5UJb8n0Q=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://junbread.win/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junbread.win/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junbread.win/favicon-32x32.png><link rel=apple-touch-icon href=https://junbread.win/apple-touch-icon.png><link rel=mask-icon href=https://junbread.win/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet type=text/css crossorigin href=//cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/variable/pretendardvariable-dynamic-subset.css><link rel=stylesheet type=text/css crossorigin href="//fonts.googleapis.com/css2?family=Source+Code+Pro"><script async src="https://www.googletagmanager.com/gtag/js?id=G-0QLLXH086F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0QLLXH086F",{anonymize_ip:!1})}</script><meta property="og:title" content="이펙티브 자바 5장 정리"><meta property="og:description" content="제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.
아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.
→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.
public class Raw { public static void main(String[] args) { List<String> strings = new ArrayList<>(); unsafeAdd(strings, Integer."><meta property="og:type" content="article"><meta property="og:url" content="https://junbread.win/posts/2021/effective-java-05/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-12T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="이펙티브 자바 5장 정리"><meta name=twitter:description content="제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.
아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.
→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.
public class Raw { public static void main(String[] args) { List<String> strings = new ArrayList<>(); unsafeAdd(strings, Integer."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://junbread.win/posts/"},{"@type":"ListItem","position":3,"name":"이펙티브 자바 5장 정리","item":"https://junbread.win/posts/2021/effective-java-05/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"이펙티브 자바 5장 정리","name":"이펙티브 자바 5장 정리","description":"제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.\n아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.\n→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.\npublic class Raw { public static void main(String[] args) { List\u0026lt;String\u0026gt; strings = new ArrayList\u0026lt;\u0026gt;(); unsafeAdd(strings, Integer.","keywords":["Study","Java"],"articleBody":"제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.\n아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.\n→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.\npublic class Raw { public static void main(String[] args) { List\u003cString\u003e strings = new ArrayList\u003c\u003e(); unsafeAdd(strings, Integer.valueOf(42)); String s = strings.get(0); // 컴파일러가 자동으로 형변환 코드를 넣어준다. } private static void unsafeAdd(List list, Object o) { list.add(o); } } List, List의 차이 List는 제네릭과 무관하다. List는 모든 타입을 허용한다고 명시적으로 컴파일러에게 정보를 전달해주는 것이다. 원소의 타입을 모른 채 사용하고 싶다면? 비한정적 와일드카드 타입을 사용하자. List\u003c?\u003e 이 경우 리스트에 아무 원소도 넣을 수 없게 된다. 이런 제약을 받아들일 수 없다면 제네릭 메서드, 한정적 와일드카드 타입을 이용하자. 단, 클래스 리터럴을 사용하거나, instanceof 연산자 사용시에는 로 타입을 사용해야 한다. (실체화 불가능) 아이템 27: 비검사 경고를 제거하라 비검사 경고는 중요하니 무시하지 말자. 잠재적 ClassCastException 오류를 일으킬 수 있다.\n경고를 제거할 수 없지만 타입이 안전하다고 확신할 수 있다면 @SuppressWarnings(\"unchecked\") 어노테이션을 붙여 경고를 숨기자. 가능한 좁은 범위에 적용해야 한다. (오류 가능성을 줄이기 위해) 경고를 무시해도 안전한 이유를 주석으로 같이 남겨두도록 하자. 아이템 28: 배열보다는 리스트를 사용하라 배열 vs 제네릭 배열은 공변(covariant)이다. Sub 클래스가 Super 라는 클래스의 하위 타입이라면, 배열 Sub[]은 배열 Super[]의 하위 타입이 된다. 제네릭은 불공변(invariant)이다. 서로 다른 Type1과 Type2가 있을 때, List은 List의 상위 타입도 하위 타입도 아니다. Object[] objectArray = new Long[1]; ObjectArray[0] = \"타입이 달라 넣을 수 없다.\"; // ArrayStoreException을 던진다. List\u003cObject\u003e ol = new ArrayList\u003cLong\u003e(); // 호환되지 않는 타입이다. ol.add(\"타입이 달라 넣을 수 없다.\"); 배열에서는 위와 같은 실수를 런타임에야 알 수 있지만, 리스트는 코드를 실행하기 전에 알 수 있다.\n배열은 실체화된다. 런타임에도 원소의 타입을 인지하고 확인한다. 제네릭은 런타임 시에 타입이 소거된다. 제네릭 지원 전의 레거시 코드와 함께 사용하기 위함 제네릭 배열을 생성할 수 없는 이유 제네릭 배열은 타입 안전하지 않다.\nList\u003cString\u003e[] stringLists = new List\u003cString\u003e[1]; // (1) List\u003cInteger\u003e intList = List.of(42); // (2) Object[] objects = stringLists; // (3) objects[0] = intList; // (4) String s = stringLists[0].get(0); // (5) (2)는 원소가 하나인 리스트를 생성했다. (3)은 (1)을 Object 배열에 할당한다. 배열은 공변이니 아무 문제없다. (4)는 (2)에서 생성한 인스턴스를 Object 배열의 첫 번째 원소로 저장한다. 제네릭은 소거 방식으로 구현되어서 성공한다. (5) (1)에서 List만 담겠다고 했으나, 배열에는 현재 List가 담겨있다. 첫 번째 원소를 꺼내어 String으로 형변환할 때 ClassCastException가 발생한다. E, List, List과 같은 타입을 실체화 불가 타입(non-reifiable type) 이라고 한다.\n제네릭의 소거 특성으로 인해 실체화되지 않아 런타임 시에 컴파일 타임보다 타입 정보를 적게 갖는다. 제네릭과 배열은 궁합이 맞지 않기 때문에, 가급적 함께 사용하지 않고 대신 리스트를 사용하는 것이 좋다.\n아이템 29: 이왕이면 제네릭 타입으로 만들라 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 사용하기에도 편리하다.\n기존 클래스를 제네릭 타입으로 변경하는 방법 // Object 기반으로 구현된 스택 public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object result = elements[--size]; elements[size] = null; return result; } public boolean isEmpty() { return size == 0; } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } } // E[]를 이용한 제네릭 스택 (170-174쪽) public class Stack\u003cE\u003e { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; // 코드 29-3 배열을 사용한 코드를 제네릭으로 만드는 방법 1 (172쪽) // 배열 elements는 push(E)로 넘어온 E 인스턴스만 담는다. // 따라서 타입 안전성을 보장하지만, // 이 배열의 런타임 타입은 E[]가 아닌 Object[]다! @SuppressWarnings(\"unchecked\") public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(E e) { ensureCapacity(); elements[size++] = e; } public E pop() { if (size == 0) throw new EmptyStackException(); E result = elements[--size]; elements[size] = null; // 다 쓴 참조 해제 return result; } public boolean isEmpty() { return size == 0; } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } // 코드 29-5 제네릭 Stack을 사용하는 맛보기 프로그램 (174쪽) public static void main(String[] args) { Stack\u003cString\u003e stack = new Stack\u003c\u003e(); for (String arg : args) stack.push(arg); while (!stack.isEmpty()) System.out.println(stack.pop().toUpperCase()); } } // Object[]를 이용한 제네릭 Stack (170-174쪽) public class Stack\u003cE\u003e { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(E e) { ensureCapacity(); elements[size++] = e; } // 코드 29-4 배열을 사용한 코드를 제네릭으로 만드는 방법 2 (173쪽) // 비검사 경고를 적절히 숨긴다. public E pop() { if (size == 0) throw new EmptyStackException(); // push에서 E 타입만 허용하므로 이 형변환은 안전하다. @SuppressWarnings(\"unchecked\") E result = (E) elements[--size]; elements[size] = null; // 다 쓴 참조 해제 return result; } public boolean isEmpty() { return size == 0; } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); } // 코드 29-5 제네릭 Stack을 사용하는 맛보기 프로그램 (174쪽) public static void main(String[] args) { Stack\u003cString\u003e stack = new Stack\u003c\u003e(); for (String arg : args) stack.push(arg); while (!stack.isEmpty()) System.out.println(stack.pop().toUpperCase()); } 제네릭 타입은 타입 매개변수에 대부분의 제약을 두지 않지만 기본 타입은 사용할 수 없다.\n→ 박싱된 기본 타입을 통해 우회할 수 있다.\n타입 매개변수에 제약을 두는 한정적 타입 매개변수\n// java.util.concurrent.DelayQueue class DelayQueue\u003cE extends Delayed\u003e implements BlockingQueue\u003cE\u003e 는 Delayed의 하위 타입만 받겠다는 뜻이 된다. DelayQueue 자신과 이를 사용하는 클라이언트는 DelayQueue의 원소에서 형변환 없이 곧바로 Delayed 클래스의 메서드를 호출할 수 있다. 아이템 30: 이왕이면 제네릭 메서드로 만들라 메서드도 제네릭으로 만들 수 있다.\npublic static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; } // 코드 30-2 제네릭 메서드 (177쪽) public static \u003cE\u003e Set\u003cE\u003e union(Set\u003cE\u003e s1, Set\u003cE\u003e s2) { Set\u003cE\u003e result = new HashSet\u003c\u003e(s1); result.addAll(s2); return result; } 제네릭 싱글톤 팩터리 제네릭은 런타임에 타입 정보가 소거되기 때문에 하나의 객체를 어떤 타입으로든 매개변수화할 수 있다. 요청한 타입 매개변수에 맞도록 매번 그 객체의 타입을 변경해주는 정적 팩터리를 만들어야 한다. ex) Collections.emptySet() 재귀적 타입 한정 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정 주로 타입의 순서를 정하는 Comparable 인터페이스와 함께 쓰인다. ","wordCount":"1913","inLanguage":"en","datePublished":"2021-04-12T00:00:00Z","dateModified":"2021-04-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://junbread.win/posts/2021/effective-java-05/"},"publisher":{"@type":"Organization","name":"Junbread🥐","logo":{"@type":"ImageObject","url":"https://junbread.win/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junbread.win accesskey=h title="Junbread🥐 (Alt + H)">Junbread🥐</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://junbread.win/about title=About><span>About</span></a></li><li><a href=https://junbread.win/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://junbread.win/tags/ title=태그><span>태그</span></a></li><li><a href=https://junbread.win/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://junbread.win>Home</a>&nbsp;»&nbsp;<a href=https://junbread.win/posts/>Posts</a></div><h1 class=post-title>이펙티브 자바 5장 정리</h1><div class=post-meta><span title='2021-04-12 00:00:00 +0000 UTC'>April 12, 2021</span>&nbsp;·&nbsp;9 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-26-%eb%a1%9c-%ed%83%80%ec%9e%85%ec%9d%80-%ec%82%ac%ec%9a%a9%ed%95%98%ec%a7%80-%eb%a7%90%eb%9d%bc aria-label="아이템 26: 로 타입은 사용하지 말라">아이템 26: 로 타입은 사용하지 말라</a><ul><li><a href=#list-listobject%ec%9d%98-%ec%b0%a8%ec%9d%b4 aria-label="List, List&amp;lt;Object&amp;gt;의 차이"><code>List</code>, <code>List&lt;Object></code>의 차이</a></li><li><a href=#%ec%9b%90%ec%86%8c%ec%9d%98-%ed%83%80%ec%9e%85%ec%9d%84-%eb%aa%a8%eb%a5%b8-%ec%b1%84-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b3%a0-%ec%8b%b6%eb%8b%a4%eb%a9%b4 aria-label="원소의 타입을 모른 채 사용하고 싶다면?">원소의 타입을 모른 채 사용하고 싶다면?</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-27-%eb%b9%84%ea%b2%80%ec%82%ac-%ea%b2%bd%ea%b3%a0%eb%a5%bc-%ec%a0%9c%ea%b1%b0%ed%95%98%eb%9d%bc aria-label="아이템 27: 비검사 경고를 제거하라">아이템 27: 비검사 경고를 제거하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-28-%eb%b0%b0%ec%97%b4%eb%b3%b4%eb%8b%a4%eb%8a%94-%eb%a6%ac%ec%8a%a4%ed%8a%b8%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 28: 배열보다는 리스트를 사용하라">아이템 28: 배열보다는 리스트를 사용하라</a><ul><li><a href=#%eb%b0%b0%ec%97%b4-vs-%ec%a0%9c%eb%84%a4%eb%a6%ad aria-label="배열 vs 제네릭"><strong>배열 vs 제네릭</strong></a></li><li><a href=#%ec%a0%9c%eb%84%a4%eb%a6%ad-%eb%b0%b0%ec%97%b4%ec%9d%84-%ec%83%9d%ec%84%b1%ed%95%a0-%ec%88%98-%ec%97%86%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="제네릭 배열을 생성할 수 없는 이유"><strong>제네릭 배열을 생성할 수 없는 이유</strong></a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-29-%ec%9d%b4%ec%99%95%ec%9d%b4%eb%a9%b4-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%83%80%ec%9e%85%ec%9c%bc%eb%a1%9c-%eb%a7%8c%eb%93%a4%eb%9d%bc aria-label="아이템 29: 이왕이면 제네릭 타입으로 만들라">아이템 29: 이왕이면 제네릭 타입으로 만들라</a><ul><li><a href=#%ea%b8%b0%ec%a1%b4-%ed%81%b4%eb%9e%98%ec%8a%a4%eb%a5%bc-%ec%a0%9c%eb%84%a4%eb%a6%ad-%ed%83%80%ec%9e%85%ec%9c%bc%eb%a1%9c-%eb%b3%80%ea%b2%bd%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="기존 클래스를 제네릭 타입으로 변경하는 방법">기존 클래스를 제네릭 타입으로 변경하는 방법</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-30-%ec%9d%b4%ec%99%95%ec%9d%b4%eb%a9%b4-%ec%a0%9c%eb%84%a4%eb%a6%ad-%eb%a9%94%ec%84%9c%eb%93%9c%eb%a1%9c-%eb%a7%8c%eb%93%a4%eb%9d%bc aria-label="아이템 30: 이왕이면 제네릭 메서드로 만들라">아이템 30: 이왕이면 제네릭 메서드로 만들라</a><ul><li><a href=#%ec%a0%9c%eb%84%a4%eb%a6%ad-%ec%8b%b1%ea%b8%80%ed%86%a4-%ed%8c%a9%ed%84%b0%eb%a6%ac aria-label="제네릭 싱글톤 팩터리"><strong>제네릭 싱글톤 팩터리</strong></a></li><li><a href=#%ec%9e%ac%ea%b7%80%ec%a0%81-%ed%83%80%ec%9e%85-%ed%95%9c%ec%a0%95 aria-label="재귀적 타입 한정"><strong>재귀적 타입 한정</strong></a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-31-%ed%95%9c%ec%a0%95%ec%a0%81-%ec%99%80%ec%9d%bc%eb%93%9c%ec%b9%b4%eb%93%9c%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%b4-api-%ec%9c%a0%ec%97%b0%ec%84%b1%ec%9d%84-%eb%86%92%ec%9d%b4%eb%9d%bc aria-label="아이템 31: 한정적 와일드카드를 사용해 API 유연성을 높이라">아이템 31: 한정적 와일드카드를 사용해 API 유연성을 높이라</a><ul><li><a href=#%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad aria-label=주의사항>주의사항</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-32-%ec%a0%9c%eb%84%a4%eb%a6%ad%ea%b3%bc-%ea%b0%80%eb%b3%80%ec%9d%b8%ec%88%98%eb%a5%bc-%ed%95%a8%ea%bb%98-%ec%93%b8-%eb%95%8c%eb%8a%94-%ec%8b%a0%ec%a4%91%ed%95%98%eb%9d%bc aria-label="아이템 32: 제네릭과 가변인수를 함께 쓸 때는 신중하라">아이템 32: 제네릭과 가변인수를 함께 쓸 때는 신중하라</a><ul><li><a href=#%ec%a0%9c%eb%84%a4%eb%a6%ad-%ea%b0%80%eb%b3%80%ec%9d%b8%ec%88%98-%eb%b0%b0%ec%97%b4%ec%9d%84-%ec%95%88%ec%a0%84%ed%95%98%ea%b2%8c-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="제네릭 가변인수 배열을 안전하게 사용하는 방법">제네릭 가변인수 배열을 안전하게 사용하는 방법</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-33-%ed%83%80%ec%9e%85-%ec%95%88%ec%a0%84-%ec%9d%b4%ec%a2%85-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ea%b3%a0%eb%a0%a4%ed%95%98%eb%9d%bc aria-label="아이템 33: 타입 안전 이종 컨테이너를 고려하라">아이템 33: 타입 안전 이종 컨테이너를 고려하라</a><ul><li><a href=#%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad-1 aria-label=주의사항>주의사항</a></li><li><a href=#%ec%8a%88%ed%8d%bc-%ed%83%80%ec%9e%85-%ed%86%a0%ed%81%b0 aria-label="슈퍼 타입 토큰">슈퍼 타입 토큰</a></li></ul></li></ul></div></details></div><div class=post-content><p>제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.</p><h2 id=아이템-26-로-타입은-사용하지-말라>아이템 26: 로 타입은 사용하지 말라<a hidden class=anchor aria-hidden=true href=#아이템-26-로-타입은-사용하지-말라>#</a></h2><p>로 타입이란 제네릭에서 <strong>타입 매개변수를 전혀 사용하지 않은 경우</strong>를 말한다.</p><p>→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Raw</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> strings <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        unsafeAdd<span style=color:#f92672>(</span>strings<span style=color:#f92672>,</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>valueOf</span><span style=color:#f92672>(</span><span style=color:#ae81ff>42</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        String s <span style=color:#f92672>=</span> strings<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#ae81ff>0</span><span style=color:#f92672>);</span> <span style=color:#75715e>// 컴파일러가 자동으로 형변환 코드를 넣어준다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unsafeAdd</span><span style=color:#f92672>(</span>List list<span style=color:#f92672>,</span> Object o<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        list<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>o<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=list-listobject의-차이><code>List</code>, <code>List&lt;Object></code>의 차이<a hidden class=anchor aria-hidden=true href=#list-listobject의-차이>#</a></h3><ul><li><code>List</code>는 제네릭과 무관하다.</li><li><code>List&lt;Object></code>는 모든 타입을 허용한다고 명시적으로 컴파일러에게 정보를 전달해주는 것이다.</li></ul><h3 id=원소의-타입을-모른-채-사용하고-싶다면>원소의 타입을 모른 채 사용하고 싶다면?<a hidden class=anchor aria-hidden=true href=#원소의-타입을-모른-채-사용하고-싶다면>#</a></h3><ul><li>비한정적 와일드카드 타입을 사용하자. <code>List&lt;?></code><ul><li>이 경우 리스트에 아무 원소도 넣을 수 없게 된다.</li><li>이런 제약을 받아들일 수 없다면 제네릭 메서드, 한정적 와일드카드 타입을 이용하자.</li></ul></li><li>단, 클래스 리터럴을 사용하거나, instanceof 연산자 사용시에는 로 타입을 사용해야 한다. (실체화 불가능)</li></ul><h2 id=아이템-27-비검사-경고를-제거하라>아이템 27: 비검사 경고를 제거하라<a hidden class=anchor aria-hidden=true href=#아이템-27-비검사-경고를-제거하라>#</a></h2><p>비검사 경고는 중요하니 무시하지 말자. 잠재적 ClassCastException 오류를 일으킬 수 있다.</p><ul><li>경고를 제거할 수 없지만 타입이 안전하다고 확신할 수 있다면  <code>@SuppressWarnings("unchecked")</code> 어노테이션을 붙여 경고를 숨기자.<ul><li>가능한 좁은 범위에 적용해야 한다. (오류 가능성을 줄이기 위해)</li><li>경고를 무시해도 안전한 이유를 주석으로 같이 남겨두도록 하자.</li></ul></li></ul><h2 id=아이템-28-배열보다는-리스트를-사용하라>아이템 28: 배열보다는 리스트를 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-28-배열보다는-리스트를-사용하라>#</a></h2><h3 id=배열-vs-제네릭><strong>배열 vs 제네릭</strong><a hidden class=anchor aria-hidden=true href=#배열-vs-제네릭>#</a></h3><ul><li>배열은 공변(covariant)이다.<ul><li><code>Sub</code> 클래스가 <code>Super</code> 라는 클래스의 하위 타입이라면, 배열 <code>Sub[]</code>은 배열 <code>Super[]</code>의 하위 타입이 된다.</li></ul></li><li>제네릭은 불공변(invariant)이다.<ul><li>서로 다른 Type1과 Type2가 있을 때, <code>List&lt;Type1></code>은 <code>List&lt;Type2></code>의 상위 타입도 하위 타입도 아니다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#f92672>[]</span> objectArray <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Long<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>ObjectArray<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;타입이 달라 넣을 수 없다.&#34;</span><span style=color:#f92672>;</span> <span style=color:#75715e>// ArrayStoreException을 던진다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> ol <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Long<span style=color:#f92672>&gt;();</span> <span style=color:#75715e>// 호환되지 않는 타입이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ol<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;타입이 달라 넣을 수 없다.&#34;</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><p>배열에서는 위와 같은 실수를 런타임에야 알 수 있지만, 리스트는 코드를 실행하기 전에 알 수 있다.</p><ul><li>배열은 실체화된다.<ul><li>런타임에도 원소의 타입을 인지하고 확인한다.</li></ul></li><li>제네릭은 런타임 시에 타입이 소거된다.<ul><li>제네릭 지원 전의 레거시 코드와 함께 사용하기 위함</li></ul></li></ul><h3 id=제네릭-배열을-생성할-수-없는-이유><strong>제네릭 배열을 생성할 수 없는 이유</strong><a hidden class=anchor aria-hidden=true href=#제네릭-배열을-생성할-수-없는-이유>#</a></h3><p>제네릭 배열은 타입 안전하지 않다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;[]</span> stringLists <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>];</span>   <span style=color:#75715e>// (1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> intList <span style=color:#f92672>=</span> List<span style=color:#f92672>.</span><span style=color:#a6e22e>of</span><span style=color:#f92672>(</span><span style=color:#ae81ff>42</span><span style=color:#f92672>);</span>                <span style=color:#75715e>// (2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Object<span style=color:#f92672>[]</span> objects <span style=color:#f92672>=</span> stringLists<span style=color:#f92672>;</span>                     <span style=color:#75715e>// (3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>objects<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> intList<span style=color:#f92672>;</span>                               <span style=color:#75715e>// (4)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>String s <span style=color:#f92672>=</span> stringLists<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>].</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#ae81ff>0</span><span style=color:#f92672>);</span>                   <span style=color:#75715e>// (5)
</span></span></span></code></pre></div><ul><li>(2)는 원소가 하나인 리스트를 생성했다.</li><li>(3)은 (1)을 Object 배열에 할당한다. 배열은 공변이니 아무 문제없다.</li><li>(4)는 (2)에서 생성한 인스턴스를 Object 배열의 첫 번째 원소로 저장한다.<ul><li>제네릭은 소거 방식으로 구현되어서 성공한다.</li></ul></li><li>(5) (1)에서 <code>List&lt;String></code>만 담겠다고 했으나, 배열에는 현재 <code>List&lt;Integer></code>가 담겨있다.<ul><li>첫 번째 원소를 꺼내어 String으로 형변환할 때 <code>ClassCastException</code>가 발생한다.</li></ul></li></ul><p><code>E</code>, <code>List&lt;E></code>, <code>List&lt;String></code>과 같은 타입을 <strong>실체화 불가 타입(non-reifiable type)</strong> 이라고 한다.</p><ul><li>제네릭의 소거 특성으로 인해 실체화되지 않아 런타임 시에 컴파일 타임보다 타입 정보를 적게 갖는다.</li></ul><p>제네릭과 배열은 궁합이 맞지 않기 때문에, 가급적 함께 사용하지 않고 대신 리스트를 사용하는 것이 좋다.</p><h2 id=아이템-29-이왕이면-제네릭-타입으로-만들라>아이템 29: 이왕이면 제네릭 타입으로 만들라<a hidden class=anchor aria-hidden=true href=#아이템-29-이왕이면-제네릭-타입으로-만들라>#</a></h2><p>클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 사용하기에도 편리하다.</p><h3 id=기존-클래스를-제네릭-타입으로-변경하는-방법>기존 클래스를 제네릭 타입으로 변경하는 방법<a hidden class=anchor aria-hidden=true href=#기존-클래스를-제네릭-타입으로-변경하는-방법>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Object 기반으로 구현된 스택
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Object<span style=color:#f92672>[]</span> elements<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_INITIAL_CAPACITY <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stack</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        elements <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>DEFAULT_INITIAL_CAPACITY<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span><span style=color:#f92672>(</span>Object e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ensureCapacity<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>pop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> EmptyStackException<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Object result <span style=color:#f92672>=</span> elements<span style=color:#f92672>[--</span>size<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureCapacity</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>elements<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> size<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            elements <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>copyOf</span><span style=color:#f92672>(</span>elements<span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> size <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// E[]를 이용한 제네릭 스택 (170-174쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> E<span style=color:#f92672>[]</span> elements<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_INITIAL_CAPACITY <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 29-3 배열을 사용한 코드를 제네릭으로 만드는 방법 1 (172쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 배열 elements는 push(E)로 넘어온 E 인스턴스만 담는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 따라서 타입 안전성을 보장하지만,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 이 배열의 런타임 타입은 E[]가 아닌 Object[]다!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stack</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        elements <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>E<span style=color:#f92672>[])</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>DEFAULT_INITIAL_CAPACITY<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span><span style=color:#f92672>(</span>E e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ensureCapacity<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> E <span style=color:#a6e22e>pop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> EmptyStackException<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        E result <span style=color:#f92672>=</span> elements<span style=color:#f92672>[--</span>size<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> <span style=color:#75715e>// 다 쓴 참조 해제
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureCapacity</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>elements<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> size<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            elements <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>copyOf</span><span style=color:#f92672>(</span>elements<span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> size <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 29-5 제네릭 Stack을 사용하는 맛보기 프로그램 (174쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> stack <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String arg <span style=color:#f92672>:</span> args<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span><span style=color:#a6e22e>push</span><span style=color:#f92672>(</span>arg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>stack<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>stack<span style=color:#f92672>.</span><span style=color:#a6e22e>pop</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toUpperCase</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Object[]를 이용한 제네릭 Stack (170-174쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Object<span style=color:#f92672>[]</span> elements<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_INITIAL_CAPACITY <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stack</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        elements <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>DEFAULT_INITIAL_CAPACITY<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span><span style=color:#f92672>(</span>E e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ensureCapacity<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 29-4 배열을 사용한 코드를 제네릭으로 만드는 방법 2 (173쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 비검사 경고를 적절히 숨긴다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> E <span style=color:#a6e22e>pop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> EmptyStackException<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// push에서 E 타입만 허용하므로 이 형변환은 안전하다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span> E result <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>(</span>E<span style=color:#f92672>)</span> elements<span style=color:#f92672>[--</span>size<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> <span style=color:#75715e>// 다 쓴 참조 해제
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureCapacity</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>elements<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> size<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            elements <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>copyOf</span><span style=color:#f92672>(</span>elements<span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> size <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 29-5 제네릭 Stack을 사용하는 맛보기 프로그램 (174쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> stack <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String arg <span style=color:#f92672>:</span> args<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span><span style=color:#a6e22e>push</span><span style=color:#f92672>(</span>arg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>stack<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>stack<span style=color:#f92672>.</span><span style=color:#a6e22e>pop</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toUpperCase</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li><p>제네릭 타입은 타입 매개변수에 대부분의 제약을 두지 않지만 기본 타입은 사용할 수 없다.</p><p>→ 박싱된 기본 타입을 통해 우회할 수 있다.</p></li><li><p>타입 매개변수에 제약을 두는 한정적 타입 매개변수</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// java.util.concurrent.DelayQueue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DelayQueue</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> Delayed<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> BlockingQueue<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><ul><li><code>&lt;E extends Delayed></code>는 Delayed의 하위 타입만 받겠다는 뜻이 된다.<ul><li>DelayQueue 자신과 이를 사용하는 클라이언트는 DelayQueue의 원소에서 형변환 없이 곧바로 Delayed 클래스의 메서드를 호출할 수 있다.</li></ul></li></ul><h2 id=아이템-30-이왕이면-제네릭-메서드로-만들라>아이템 30: 이왕이면 제네릭 메서드로 만들라<a hidden class=anchor aria-hidden=true href=#아이템-30-이왕이면-제네릭-메서드로-만들라>#</a></h2><p>메서드도 제네릭으로 만들 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Set <span style=color:#a6e22e>union</span><span style=color:#f92672>(</span>Set s1<span style=color:#f92672>,</span> Set s2<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Set result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>(</span>s1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    result<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>s2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 30-2 제네릭 메서드 (177쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> Set<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>union</span><span style=color:#f92672>(</span>Set<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> s1<span style=color:#f92672>,</span> Set<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> s2<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Set<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;&gt;(</span>s1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    result<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>s2<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=제네릭-싱글톤-팩터리><strong>제네릭 싱글톤 팩터리</strong><a hidden class=anchor aria-hidden=true href=#제네릭-싱글톤-팩터리>#</a></h3><ul><li>제네릭은 런타임에 타입 정보가 소거되기 때문에 하나의 객체를 어떤 타입으로든 매개변수화할 수 있다.</li><li>요청한 타입 매개변수에 맞도록 매번 그 객체의 타입을 변경해주는 정적 팩터리를 만들어야 한다. ex) <code>Collections.emptySet()</code></li></ul><h3 id=재귀적-타입-한정><strong>재귀적 타입 한정</strong><a hidden class=anchor aria-hidden=true href=#재귀적-타입-한정>#</a></h3><ul><li>자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정<ul><li>주로 타입의 순서를 정하는 Comparable 인터페이스와 함께 쓰인다.</li><li><code>&lt;E extends Comparable&lt;E>></code>는 “모든 타입 E는 자신과 비교할 수 있다” 라고 읽을 수 있다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 30-7 컬렉션에서 최댓값을 반환한다. - 재귀적 타입 한정 사용 (179쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> Comparable<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;&gt;</span> E <span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>Collection<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> c<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;컬렉션이 비어 있습니다.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    E result <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>E e <span style=color:#f92672>:</span> c<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>compareTo</span><span style=color:#f92672>(</span>result<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> Objects<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=아이템-31-한정적-와일드카드를-사용해-api-유연성을-높이라>아이템 31: 한정적 와일드카드를 사용해 API 유연성을 높이라<a hidden class=anchor aria-hidden=true href=#아이템-31-한정적-와일드카드를-사용해-api-유연성을-높이라>#</a></h2><ul><li><p>매개변수화 타입은 불공변(invariant)이다.</p><ul><li><code>List&lt;Object></code>를 파라미터로 받는 메서드의 인자로 <code>List&lt;String></code>을 전달할 수 없다.</li></ul></li><li><p>제네릭을 좀 더 유연하게 사용할 수는 없을까?</p><p>→ 입력 파라미터에 와일드카드 타입을 사용하자.</p></li></ul><p>한정적 와일드카드를 사용할 때는 <strong>PECS</strong>를 기억하자.</p><ul><li>Producer - Extend: 메서드의 매개변수가 생산자의 역할을 한다면 extend를 사용</li><li>Consumer - Super: 메서드의 매개변수가 소비자의 역할을 한다면 super를 사용</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 와일드카드 타입을 이용해 대량 작업을 수행하는 메서드를 포함한 제네릭 스택 (181-183쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> E<span style=color:#f92672>[]</span> elements<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_INITIAL_CAPACITY <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 29-3 배열을 사용한 코드를 제네릭으로 만드는 방법 1 (172쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 배열 elements는 push(E)로 넘어온 E 인스턴스만 담는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 따라서 타입 안전성을 보장하지만,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 이 배열의 런타임 타입은 E[]가 아닌 Object[]다!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stack</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        elements <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>E<span style=color:#f92672>[])</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>DEFAULT_INITIAL_CAPACITY<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span><span style=color:#f92672>(</span>E e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ensureCapacity<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> E <span style=color:#a6e22e>pop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>size<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> EmptyStackException<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        E result <span style=color:#f92672>=</span> elements<span style=color:#f92672>[--</span>size<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>        elements<span style=color:#f92672>[</span>size<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> <span style=color:#75715e>// 다 쓴 참조 해제
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureCapacity</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>elements<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> size<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            elements <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>copyOf</span><span style=color:#f92672>(</span>elements<span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> size <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//    // 코드 31-1 와일드카드 타입을 사용하지 않은 pushAll 메서드 - 결함이 있다! (181쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    public void pushAll(Iterable&lt;E&gt; src) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//        for (E e : src)
</span></span></span><span style=display:flex><span><span style=color:#75715e>//            push(e);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>     <span style=color:#75715e>// 코드 31-2 E 생산자(producer) 매개변수에 와일드카드 타입 적용 (182쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pushAll</span><span style=color:#f92672>(</span>Iterable<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> E<span style=color:#f92672>&gt;</span> src<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>E e <span style=color:#f92672>:</span> src<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            push<span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//    // 코드 31-3 와일드카드 타입을 사용하지 않은 popAll 메서드 - 결함이 있다! (183쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    public void popAll(Collection&lt;E&gt; dst) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//        while (!isEmpty())
</span></span></span><span style=display:flex><span><span style=color:#75715e>//            dst.add(pop());
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 31-4 E 소비자(consumer) 매개변수에 와일드카드 타입 적용 (183쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>popAll</span><span style=color:#f92672>(</span>Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> E<span style=color:#f92672>&gt;</span> dst<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>isEmpty<span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>            dst<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>pop<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 제네릭 Stack을 사용하는 맛보기 프로그램
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>Number<span style=color:#f92672>&gt;</span> numberStack <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        Iterable<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> integers <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>4</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>5</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>9</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        numberStack<span style=color:#f92672>.</span><span style=color:#a6e22e>pushAll</span><span style=color:#f92672>(</span>integers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Collection<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> objects <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        numberStack<span style=color:#f92672>.</span><span style=color:#a6e22e>popAll</span><span style=color:#f92672>(</span>objects<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>objects<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=주의사항>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h3><ul><li>메서드의 리턴값으로 와일드카드를 사용하는 것은 피해야 한다.<ul><li>클라이언트에서도 와일드카드 자료형을 사용해야 하기 때문</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>swapTest</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 방법1) 비한정적 타입 매개변수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>typeArgSwap</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> i<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> j<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        list<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>j<span style=color:#f92672>,</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>)));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 방법2) 비한정적 와일드카드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wildcardSwap</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;?&gt;</span> list<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> i<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> j<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        wildcardSwapHelper<span style=color:#f92672>(</span>list<span style=color:#f92672>,</span> i<span style=color:#f92672>,</span> j<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 방법2-1) 와일드카드 형에는 null외에 어떤 값도 넣을 수 없다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 방법1과 메서드 시그니처(이름과 파라미터)가 동일하다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wildcardSwapHelper</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> list<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> i<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> j<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        list<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>j<span style=color:#f92672>,</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>i<span style=color:#f92672>)));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=아이템-32-제네릭과-가변인수를-함께-쓸-때는-신중하라>아이템 32: 제네릭과 가변인수를 함께 쓸 때는 신중하라<a hidden class=anchor aria-hidden=true href=#아이템-32-제네릭과-가변인수를-함께-쓸-때는-신중하라>#</a></h2><p>가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 생긴다.</p><p>→ 제네릭 타입 가변인수 배열에 값을 저장하게 되면 타입 안정성이 깨진다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 32-1 제네릭과 varargs를 혼용하면 타입 안전성이 깨진다! (191-192쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dangerous</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;...</span> stringLists<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> intList <span style=color:#f92672>=</span> List<span style=color:#f92672>.</span><span style=color:#a6e22e>of</span><span style=color:#f92672>(</span><span style=color:#ae81ff>42</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    Object<span style=color:#f92672>[]</span> objects <span style=color:#f92672>=</span> stringLists<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    objects<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> intList<span style=color:#f92672>;</span> <span style=color:#75715e>// 힙 오염 발생
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    String s <span style=color:#f92672>=</span> stringLists<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>].</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#ae81ff>0</span><span style=color:#f92672>);</span> <span style=color:#75715e>// ClassCastException
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    dangerous<span style=color:#f92672>(</span>List<span style=color:#f92672>.</span><span style=color:#a6e22e>of</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;There be dragons!&#34;</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>컴파일 오류는 발생하지 않지만, 인수를 건네 호출하게 되면 <code>ClassCastException</code>이 발생한다.</li><li>해당 코드 부분에 컴파일러가 생성한 형변환 코드가 숨어 있기 때문이다.</li></ul><h3 id=제네릭-가변인수-배열을-안전하게-사용하는-방법>제네릭 가변인수 배열을 안전하게 사용하는 방법<a hidden class=anchor aria-hidden=true href=#제네릭-가변인수-배열을-안전하게-사용하는-방법>#</a></h3><p>varargs 매개변수 배열이 순수하게 인수들을 전달한다면 그 메서드는 안전하다.</p><ul><li>메서드가 가변인수 메서드가 호출될 때 생성되는 varargs 매개변수 배열에 아무것도 저장하지 않아야 한다.</li><li>배열의 참조가 신뢰할 수 없는 곳에 노출되지 않아야 한다.</li><li>(메서드를 재정의할 수 없어야 한다.)</li></ul><h2 id=아이템-33-타입-안전-이종-컨테이너를-고려하라>아이템 33: 타입 안전 이종 컨테이너를 고려하라<a hidden class=anchor aria-hidden=true href=#아이템-33-타입-안전-이종-컨테이너를-고려하라>#</a></h2><p>제네릭에서 매개변수화되는 대상은 원소가 아닌 컨테이너 자신이다. 따라서 하나의 컨테이너에서 매개변수화할 수 있는 타입의 수가 제한된다.</p><p>좀 더 유연한 구현을 위해서 타입 안전 이종 컨테이너 패턴을 사용할 수 있다.</p><ul><li><p>타입 안전 이종 컨테이너 패턴: 컨테이너 대신 키를 매개변수화한 다음에 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공한다.</p><p>→ 컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴을 타입 토큰이라고 한다.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 타입 안전 이종 컨테이너 패턴 (199-202쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Favorites</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 33-3 타입 안전 이종 컨테이너 패턴 - 구현 (200쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>Class<span style=color:#f92672>&lt;?&gt;,</span> Object<span style=color:#f92672>&gt;</span> favorites <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>putFavorite</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> type<span style=color:#f92672>,</span> T instance<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        favorites<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>Objects<span style=color:#f92672>.</span><span style=color:#a6e22e>requireNonNull</span><span style=color:#f92672>(</span>type<span style=color:#f92672>),</span> instance<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> T <span style=color:#a6e22e>getFavorite</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> type<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> type<span style=color:#f92672>.</span><span style=color:#a6e22e>cast</span><span style=color:#f92672>(</span>favorites<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>type<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//    // 코드 33-4 동적 형변환으로 런타임 타입 안전성 확보 (202쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//        favorites.put(Objects.requireNonNull(type), type.cast(instance));
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 33-2 타입 안전 이종 컨테이너 패턴 - 클라이언트 (199쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Favorites f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Favorites<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        f<span style=color:#f92672>.</span><span style=color:#a6e22e>putFavorite</span><span style=color:#f92672>(</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Java&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        f<span style=color:#f92672>.</span><span style=color:#a6e22e>putFavorite</span><span style=color:#f92672>(</span>Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>0xcafebabe</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        f<span style=color:#f92672>.</span><span style=color:#a6e22e>putFavorite</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Favorites<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>        String favoriteString <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span><span style=color:#a6e22e>getFavorite</span><span style=color:#f92672>(</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> favoriteInteger <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span><span style=color:#a6e22e>getFavorite</span><span style=color:#f92672>(</span>Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Class<span style=color:#f92672>&lt;?&gt;</span> favoriteClass <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span><span style=color:#a6e22e>getFavorite</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>printf</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;%s %x %s%n&#34;</span><span style=color:#f92672>,</span> favoriteString<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                favoriteInteger<span style=color:#f92672>,</span> favoriteClass<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=주의사항-1>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항-1>#</a></h3><ul><li><p>타입 토큰을 로 타입으로 넘길 경우 타입 안정성이 깨진다.</p><p>→ 동적 형변환으로 런타임 타입 안정성을 확보할 수 있다.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>f<span style=color:#f92672>.</span><span style=color:#a6e22e>putFavorite</span><span style=color:#f92672>((</span>Class<span style=color:#f92672>)</span>Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Integer의 인스턴스가 아닙니다.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> favoriteInteger <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span><span style=color:#a6e22e>getFavorite</span><span style=color:#f92672>(</span>Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</span></span></code></pre></div><ul><li>실체화가 불가능한 타입은 넣을 수 없다.<ul><li><code>String</code>이나 <code>String[]</code>은 저장할 수 있지만, <code>List&lt;String></code>은 저장할 수 없다.</li><li>우회하기 위한 방법으로는 슈퍼 타입 토큰을 사용할 수 있다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> pets <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;강아지&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;고양이&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>f<span style=color:#f92672>.</span><span style=color:#a6e22e>putFavorite</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> TypeRef<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;(){},</span> pets<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span><span style=color:#a6e22e>getFavorite</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> TypeRef<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;(){});</span>
</span></span></code></pre></div><h3 id=슈퍼-타입-토큰>슈퍼 타입 토큰<a hidden class=anchor aria-hidden=true href=#슈퍼-타입-토큰>#</a></h3><p>한마디로 요약하면, 런타임에 어떻게든 파라미터 타입에 대한 정보가 남아있도록 구현하는 것</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junbread.win/tags/study/>Study</a></li><li><a href=https://junbread.win/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://junbread.win/posts/2021/effective-java-06/><span class=title>« Prev</span><br><span>이펙티브 자바 6장 정리</span></a>
<a class=next href=https://junbread.win/posts/2021/effective-java-04/><span class=title>Next »</span><br><span>이펙티브 자바 4장 정리</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=junbread/blog data-repo-id=R_kgDOJLcBtQ data-category=Comments data-category-id=DIC_kwDOJLcBtc4CVATm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=dark data-lang=ko data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://junbread.win>Junbread🥐</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>