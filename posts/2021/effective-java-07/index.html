<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>이펙티브 자바 7장 정리 | Junbread🥐</title><meta name=keywords content="Study,Java"><meta name=description content="아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.
Collections.sort(words, new Comparator<String>() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (&#34;+&#34;, (x, y) -> x + y), MINUS (&#34;-&#34;, (x, y) -> x - y), TIMES (&#34;*&#34;, (x, y) -> x * y), DIVIDE(&#34;/&#34;, (x, y) -> x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this."><meta name=author content><link rel=canonical href=https://junbread.win/posts/2021/effective-java-07/><link crossorigin=anonymous href=/assets/css/stylesheet.f6c1b3e9443ffcf8efd37433e13b909fd545f99414f2ac3e5b22795096fc9f44.css integrity="sha256-9sGz6UQ//Pjv03Qz4TuQn9VF+ZQU8qw+WyJ5UJb8n0Q=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://junbread.win/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junbread.win/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junbread.win/favicon-32x32.png><link rel=apple-touch-icon href=https://junbread.win/apple-touch-icon.png><link rel=mask-icon href=https://junbread.win/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet type=text/css crossorigin href=//cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/variable/pretendardvariable-dynamic-subset.css><link rel=stylesheet type=text/css crossorigin href="//fonts.googleapis.com/css2?family=Source+Code+Pro"><script async src="https://www.googletagmanager.com/gtag/js?id=G-0QLLXH086F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0QLLXH086F",{anonymize_ip:!1})}</script><meta property="og:title" content="이펙티브 자바 7장 정리"><meta property="og:description" content="아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.
Collections.sort(words, new Comparator<String>() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (&#34;+&#34;, (x, y) -> x + y), MINUS (&#34;-&#34;, (x, y) -> x - y), TIMES (&#34;*&#34;, (x, y) -> x * y), DIVIDE(&#34;/&#34;, (x, y) -> x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this."><meta property="og:type" content="article"><meta property="og:url" content="https://junbread.win/posts/2021/effective-java-07/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-22T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="이펙티브 자바 7장 정리"><meta name=twitter:description content="아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.
Collections.sort(words, new Comparator<String>() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (&#34;+&#34;, (x, y) -> x + y), MINUS (&#34;-&#34;, (x, y) -> x - y), TIMES (&#34;*&#34;, (x, y) -> x * y), DIVIDE(&#34;/&#34;, (x, y) -> x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://junbread.win/posts/"},{"@type":"ListItem","position":3,"name":"이펙티브 자바 7장 정리","item":"https://junbread.win/posts/2021/effective-java-07/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"이펙티브 자바 7장 정리","name":"이펙티브 자바 7장 정리","description":"아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.\nCollections.sort(words, new Comparator\u0026lt;String\u0026gt;() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.\nCollections.sort(words, (s1, s2) -\u0026gt; Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (\u0026#34;+\u0026#34;, (x, y) -\u0026gt; x + y), MINUS (\u0026#34;-\u0026#34;, (x, y) -\u0026gt; x - y), TIMES (\u0026#34;*\u0026#34;, (x, y) -\u0026gt; x * y), DIVIDE(\u0026#34;/\u0026#34;, (x, y) -\u0026gt; x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this.","keywords":["Study","Java"],"articleBody":"아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.\nCollections.sort(words, new Comparator\u003cString\u003e() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.\nCollections.sort(words, (s1, s2) -\u003e Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (\"+\", (x, y) -\u003e x + y), MINUS (\"-\", (x, y) -\u003e x - y), TIMES (\"*\", (x, y) -\u003e x * y), DIVIDE(\"/\", (x, y) -\u003e x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this.symbol = symbol; this.op = op; } @Override public String toString() { return symbol; } public double apply(double x, double y) { return op.applyAsDouble(x, y); } } 람다 사용시의 주의점 타입을 명시해야 코드가 더 명확해질 때를 제외하고는 람다의 모든 매개변수 타입을 생략하자. 람다는 이름이 없고 문서화도 못 하기 때문에, 코드 자체로 명확히 설명되지 않거나 코드 줄 수가 많아지면 사용을 삼가자. 구현체별로 직렬화 방식이 다를 수 있기 때문에, 람다를 직렬화해서는 안 된다. 람다를 사용할 수 없는 경우 추상 클래스의 인스턴스를 만드는 경우 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만드는 경우 this가 자기 자신을 가리켜야 하는 경우 아이템 43: 람다보다는 메소드 참조를 사용하라 메소드 참조를 사용하면 람다보다도 간결한 코드를 작성할 수 있다.\nfrequencyTable.merge(s, 1, (count, incr) -\u003e count + incr); // 람다 frequencyTable.merge(s, 1, Integer::sum); // 메서드 참조 람다가 메서드 참조보다 더 간결한 경우도 있다. e.g. 람다와 메서드가 같은 클래스 내에 있을 경우\n메서드 참조 유형 정적\nstr -\u003e Integer.parseInt(str) ⇒ Integer::parseInt 한정적 (인스턴스)\nInstant then = Instant.now(); t -\u003e then.isAfter(t); Instant.now()::isAfter 비한정적 (인스턴스)\nstr -\u003e str.toLowerCase() ⇒ String::toLowerCase 클래스 생성자\n() -\u003e new TreeMap() ⇒ TreeMap::new 배열 생성자\nlen -\u003e new int[len] ⇒ int[]::new 아이템 44: 표준 함수형 인터페이스를 사용하라 자바에서는 람다에 사용할 수 있도록 다양한 모양의 표준 함수형 인터페이스를 제공하고 있다.\n람다에 사용하기 위해 직접 인터페이스를 구현하기보다는, 표준 함수형 인터페이스를 사용하자. 전용 함수형 인터페이스를 구현해야 하는 경우 e.g. Comparator\n자주 쓰이며, 이름 자체가 용도를 명확히 설명한다. 반드시 따라야 하는 규약이 있다. 유용한 디폴트 메서드를 제공할 수 있다. 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자.\n아이템 45: 스트림은 주의해서 사용하라 자바 8에서 추가된 스트림은 다량의 데이터 처리 작업을 위해 도입되었다.\n스트림 파이프라인 스트림 파이프라인은 지연 평가된다. 평가는 종단 연산이 호출될 때 이루어지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다. 스트림을 잘못 사용하면 읽기 어렵고 유지보수가 힘든 코드가 만들어진다.\n// 코드 45-2 스트림을 과하게 사용했다. - 따라 하지 말 것! (270-271쪽) public class StreamAnagrams { public static void main(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); try (Stream\u003cString\u003e words = Files.lines(dictionary)) { words.collect( groupingBy(word -\u003e word.chars().sorted() .collect(StringBuilder::new, (sb, c) -\u003e sb.append((char) c), StringBuilder::append).toString())) .values().stream() .filter(group -\u003e group.size() \u003e= minGroupSize) .map(group -\u003e group.size() + \": \" + group) .forEach(System.out::println); } } } → 도우미 메서드를 적절히 활용하자.\n// 코드 45-3 스트림을 적절히 활용하면 깔끔하고 명료해진다. (271쪽) public class HybridAnagrams { public static void main(String[] args) throws IOException { Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); try (Stream\u003cString\u003e words = Files.lines(dictionary)) { words.collect(groupingBy(word -\u003e alphabetize(word))) .values().stream() .filter(group -\u003e group.size() \u003e= minGroupSize) .forEach(g -\u003e System.out.println(g.size() + \": \" + g)); } } private static String alphabetize(String s) { char[] a = s.toCharArray(); Arrays.sort(a); return new String(a); } } 스트림과 람다 람다에서는 타입을 자주 생략하므로 매개변수 이름을 잘 지어야 한다. 도우미 메서드를 적절히 활용하는 일의 중요성은 일반 반복 코드보다는 스트림 파이프라인에서 훨씬 크다. 스트림을 쓰면 좋은 것 원소들의 시퀀스를 일관되게 변환한다. 원소들의 시퀀스를 필터링한다. 원소들의 시퀀스를 하나의 연산을 사용해 결합한다. 원소들의 시퀀스를 컬렉션에 모은다. 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다. 스트림(+람다)이 할 수 없는 것 람다에선 final 이거나 사실상 final인 변수만 읽을 수 있고, 지역변수를 수정할 수 없다. 람다는 흐름 제어가 불가능하지만, 코드 블록에서는 가능하다. 스트림과 반복문 중 어떤 쪽이 나은지 확신하기 어렵다면 직접 구현해 보고 나은 쪽을 선택하자.\n아이템 46: 스트림에서는 부작용없는 함수를 사용하라 함수형 패러다임을 지키려면 부작용없는 순수함수를 사용해야 한다.\n순수함수는 입력만이 결과에 영향을 주는 함수이며, 함수 외부의 가변 상태를 참조하지 않고 외부의 상태도 변경하지 않는 함수이다.\n스트림 파이프라인에 사용할 함수는 부작용이 없는 순수 함수를 사용해야 한다.\nforEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자. 잘못된 예 // 코드 46-1 스트림 패러다임을 이해하지 못한 채 API만 사용했다 - 따라 하지 말 것! (277쪽) Map\u003cString, Long\u003e freq = new HashMap\u003c\u003e(); try (Stream\u003cString\u003e words = new Scanner(file).tokens()) { words.forEach(word -\u003e { freq.merge(word.toLowerCase(), 1L, Long::sum); }); } 좋은 예 // 코드 46-2 스트림을 제대로 활용해 빈도표를 초기화한다. (278쪽) Map\u003cString, Long\u003e freq; try (Stream\u003cString\u003e words = new Scanner(file).tokens()) { freq = words .collect(groupingBy(String::toLowerCase, counting())); } 수집기를 사용하면 스트림의 원소를 손쉽게 컬렉션으로 모을 수 있다.\ntoList(), toSet(), toMap() … 아이템 47: 반환 타입으로는 스트림보다 컬렉션이 낫다 스트림은 반복을 지원하지 않는다. Iterable을 사용해 우회할 수 있으나, 코드가 지저분해지고 읽기 힘들어진다.\n어댑터를 사용해서 Iterable ↔ Stream간 상호 변환을 간단히 구현할 수 있다. // 스트림 \u003c-\u003e 반복자 어댑터 (285-286쪽) public class Adapters { // 코드 47-3 Stream를 Iterable로 중개해주는 어댑터 (285쪽) public static \u003cE\u003e Iterable\u003cE\u003e iterableOf(Stream\u003cE\u003e stream) { return stream::iterator; } // 코드 47-4 Iterable를 Stream로 중개해주는 어댑터 (286쪽) public static \u003cE\u003e Stream\u003cE\u003e streamOf(Iterable\u003cE\u003e iterable) { return StreamSupport.stream(iterable.spliterator(), false); } } 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 하위 타입을 사용하는 것이 일반적으로 최선이다. 원소를 이미 컬렉션에 담아 관리하고 있거나 원소 개수가 적다면 표준 컬렉션에 담아서 반환하고, 그렇지 않다면 전용 컬렉션을 구현하는 것을 검토하자. → 반환 타입은 스트림보다는, 반복과 스트림을 모두 지원할 수 있는 컬렉션 타입이 낫다.\n아이템 48: 스트림 병렬화는 주의해서 적용하라 스트림은 .parallel() 로 쉽게 병렬화할 수 있지만, 마구잡이로 사용할 경우 오히려 성능을 해치거나, 잘못된 결과를 만들 수 있다.\n데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다. 대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나, 배열, IntRange, LongRange일 때 병렬화의 효과가 가장 좋다. 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있고, 참조 지역성이 뛰어나기 때문 파이프라인이 수행하는 작업이 병렬화에 드는 추가 비용을 상쇄하지 못한다면 성능 향상에는 도움이 되지 않는다. ","wordCount":"976","inLanguage":"en","datePublished":"2021-05-22T00:00:00Z","dateModified":"2021-05-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://junbread.win/posts/2021/effective-java-07/"},"publisher":{"@type":"Organization","name":"Junbread🥐","logo":{"@type":"ImageObject","url":"https://junbread.win/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junbread.win accesskey=h title="Junbread🥐 (Alt + H)">Junbread🥐</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://junbread.win/about title=About><span>About</span></a></li><li><a href=https://junbread.win/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://junbread.win/tags/ title=태그><span>태그</span></a></li><li><a href=https://junbread.win/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://junbread.win>Home</a>&nbsp;»&nbsp;<a href=https://junbread.win/posts/>Posts</a></div><h1 class=post-title>이펙티브 자바 7장 정리</h1><div class=post-meta><span title='2021-05-22 00:00:00 +0000 UTC'>May 22, 2021</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-42-%ec%9d%b5%eb%aa%85-%ed%81%b4%eb%9e%98%ec%8a%a4%eb%b3%b4%eb%8b%a4%eb%8a%94-%eb%9e%8c%eb%8b%a4%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 42: 익명 클래스보다는 람다를 사용하라">아이템 42: 익명 클래스보다는 람다를 사용하라</a><ul><li><a href=#%eb%9e%8c%eb%8b%a4-%ec%82%ac%ec%9a%a9%ec%8b%9c%ec%9d%98-%ec%a3%bc%ec%9d%98%ec%a0%90 aria-label="람다 사용시의 주의점">람다 사용시의 주의점</a></li><li><a href=#%eb%9e%8c%eb%8b%a4%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%a0-%ec%88%98-%ec%97%86%eb%8a%94-%ea%b2%bd%ec%9a%b0 aria-label="람다를 사용할 수 없는 경우">람다를 사용할 수 없는 경우</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-43-%eb%9e%8c%eb%8b%a4%eb%b3%b4%eb%8b%a4%eb%8a%94-%eb%a9%94%ec%86%8c%eb%93%9c-%ec%b0%b8%ec%a1%b0%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 43: 람다보다는 메소드 참조를 사용하라">아이템 43: 람다보다는 메소드 참조를 사용하라</a><ul><li><a href=#%eb%a9%94%ec%84%9c%eb%93%9c-%ec%b0%b8%ec%a1%b0-%ec%9c%a0%ed%98%95 aria-label="메서드 참조 유형">메서드 참조 유형</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-44-%ed%91%9c%ec%a4%80-%ed%95%a8%ec%88%98%ed%98%95-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 44: 표준 함수형 인터페이스를 사용하라">아이템 44: 표준 함수형 인터페이스를 사용하라</a><ul><li><a href=#%ec%a0%84%ec%9a%a9-%ed%95%a8%ec%88%98%ed%98%95-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4%eb%a5%bc-%ea%b5%ac%ed%98%84%ed%95%b4%ec%95%bc-%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0 aria-label="전용 함수형 인터페이스를 구현해야 하는 경우">전용 함수형 인터페이스를 구현해야 하는 경우</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-45-%ec%8a%a4%ed%8a%b8%eb%a6%bc%ec%9d%80-%ec%a3%bc%ec%9d%98%ed%95%b4%ec%84%9c-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 45: 스트림은 주의해서 사용하라">아이템 45: 스트림은 주의해서 사용하라</a><ul><li><a href=#%ec%8a%a4%ed%8a%b8%eb%a6%bc-%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8 aria-label="스트림 파이프라인">스트림 파이프라인</a></li><li><a href=#%ec%8a%a4%ed%8a%b8%eb%a6%bc%ea%b3%bc-%eb%9e%8c%eb%8b%a4 aria-label="스트림과 람다">스트림과 람다</a></li><li><a href=#%ec%8a%a4%ed%8a%b8%eb%a6%bc%ec%9d%84-%ec%93%b0%eb%a9%b4-%ec%a2%8b%ec%9d%80-%ea%b2%83 aria-label="스트림을 쓰면 좋은 것">스트림을 쓰면 좋은 것</a></li><li><a href=#%ec%8a%a4%ed%8a%b8%eb%a6%bc%eb%9e%8c%eb%8b%a4%ec%9d%b4-%ed%95%a0-%ec%88%98-%ec%97%86%eb%8a%94-%ea%b2%83 aria-label="스트림(+람다)이 할 수 없는 것">스트림(+람다)이 할 수 없는 것</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-46-%ec%8a%a4%ed%8a%b8%eb%a6%bc%ec%97%90%ec%84%9c%eb%8a%94-%eb%b6%80%ec%9e%91%ec%9a%a9%ec%97%86%eb%8a%94-%ed%95%a8%ec%88%98%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 46: 스트림에서는 부작용없는 함수를 사용하라">아이템 46: 스트림에서는 부작용없는 함수를 사용하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-47-%eb%b0%98%ed%99%98-%ed%83%80%ec%9e%85%ec%9c%bc%eb%a1%9c%eb%8a%94-%ec%8a%a4%ed%8a%b8%eb%a6%bc%eb%b3%b4%eb%8b%a4-%ec%bb%ac%eb%a0%89%ec%85%98%ec%9d%b4-%eb%82%ab%eb%8b%a4 aria-label="아이템 47: 반환 타입으로는 스트림보다 컬렉션이 낫다">아이템 47: 반환 타입으로는 스트림보다 컬렉션이 낫다</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-48-%ec%8a%a4%ed%8a%b8%eb%a6%bc-%eb%b3%91%eb%a0%ac%ed%99%94%eb%8a%94-%ec%a3%bc%ec%9d%98%ed%95%b4%ec%84%9c-%ec%a0%81%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 48: 스트림 병렬화는 주의해서 적용하라">아이템 48: 스트림 병렬화는 주의해서 적용하라</a></li></ul></div></details></div><div class=post-content><h2 id=아이템-42-익명-클래스보다는-람다를-사용하라>아이템 42: 익명 클래스보다는 람다를 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-42-익명-클래스보다는-람다를-사용하라>#</a></h2><p>예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Collections<span style=color:#f92672>.</span><span style=color:#a6e22e>sort</span><span style=color:#f92672>(</span>words<span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Comparator<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compare</span><span style=color:#f92672>(</span>String s1<span style=color:#f92672>,</span> String s2<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>compare</span><span style=color:#f92672>(</span>s1<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>(),</span> s2<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>});</span>
</span></span></code></pre></div><p>람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Collections<span style=color:#f92672>.</span><span style=color:#a6e22e>sort</span><span style=color:#f92672>(</span>words<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>s1<span style=color:#f92672>,</span> s2<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>compare</span><span style=color:#f92672>(</span>s1<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>(),</span> s2<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>()));</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Operation <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    PLUS  <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;+&#34;</span><span style=color:#f92672>,</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> y<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>+</span> y<span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>    MINUS <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;-&#34;</span><span style=color:#f92672>,</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> y<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>-</span> y<span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>    TIMES <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;*&#34;</span><span style=color:#f92672>,</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> y<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>*</span> y<span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>    DIVIDE<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/&#34;</span><span style=color:#f92672>,</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> y<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>/</span> y<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String symbol<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> DoubleBinaryOperator op<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Operation<span style=color:#f92672>(</span>String symbol<span style=color:#f92672>,</span> DoubleBinaryOperator op<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>symbol</span> <span style=color:#f92672>=</span> symbol<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>op</span> <span style=color:#f92672>=</span> op<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> symbol<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>apply</span><span style=color:#f92672>(</span><span style=color:#66d9ef>double</span> x<span style=color:#f92672>,</span> <span style=color:#66d9ef>double</span> y<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> op<span style=color:#f92672>.</span><span style=color:#a6e22e>applyAsDouble</span><span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> y<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=람다-사용시의-주의점>람다 사용시의 주의점<a hidden class=anchor aria-hidden=true href=#람다-사용시의-주의점>#</a></h3><ul><li>타입을 명시해야 코드가 더 명확해질 때를 제외하고는 람다의 모든 매개변수 타입을 생략하자.</li><li>람다는 이름이 없고 문서화도 못 하기 때문에, 코드 자체로 명확히 설명되지 않거나 코드 줄 수가 많아지면 사용을 삼가자.</li><li>구현체별로 직렬화 방식이 다를 수 있기 때문에, 람다를 직렬화해서는 안 된다.</li></ul><h3 id=람다를-사용할-수-없는-경우>람다를 사용할 수 없는 경우<a hidden class=anchor aria-hidden=true href=#람다를-사용할-수-없는-경우>#</a></h3><ul><li>추상 클래스의 인스턴스를 만드는 경우</li><li>추상 메서드가 여러 개인 인터페이스의 인스턴스를 만드는 경우</li><li>this가 자기 자신을 가리켜야 하는 경우</li></ul><h2 id=아이템-43-람다보다는-메소드-참조를-사용하라>아이템 43: 람다보다는 메소드 참조를 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-43-람다보다는-메소드-참조를-사용하라>#</a></h2><p>메소드 참조를 사용하면 람다보다도 간결한 코드를 작성할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>frequencyTable<span style=color:#f92672>.</span><span style=color:#a6e22e>merge</span><span style=color:#f92672>(</span>s<span style=color:#f92672>,</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#f92672>(</span>count<span style=color:#f92672>,</span> incr<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> count <span style=color:#f92672>+</span> incr<span style=color:#f92672>);</span> <span style=color:#75715e>// 람다
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>frequencyTable<span style=color:#f92672>.</span><span style=color:#a6e22e>merge</span><span style=color:#f92672>(</span>s<span style=color:#f92672>,</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> Integer<span style=color:#f92672>::</span>sum<span style=color:#f92672>);</span> <span style=color:#75715e>// 메서드 참조
</span></span></span></code></pre></div><p>람다가 메서드 참조보다 더 간결한 경우도 있다. e.g. 람다와 메서드가 같은 클래스 내에 있을 경우</p><h3 id=메서드-참조-유형>메서드 참조 유형<a hidden class=anchor aria-hidden=true href=#메서드-참조-유형>#</a></h3><ul><li><p>정적</p><ul><li><code>str -> Integer.parseInt(str)</code> ⇒ <code>Integer::parseInt</code></li></ul></li><li><p>한정적 (인스턴스)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Instant then <span style=color:#f92672>=</span> Instant<span style=color:#f92672>.</span><span style=color:#a6e22e>now</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>t <span style=color:#f92672>-&gt;</span> then<span style=color:#f92672>.</span><span style=color:#a6e22e>isAfter</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Instant<span style=color:#f92672>.</span><span style=color:#a6e22e>now</span><span style=color:#f92672>()::</span>isAfter
</span></span></code></pre></div></li><li><p>비한정적 (인스턴스)</p><ul><li><code>str -> str.toLowerCase()</code> ⇒ <code>String::toLowerCase</code></li></ul></li><li><p>클래스 생성자</p><ul><li><code>() -> new TreeMap&lt;K, V>()</code> ⇒ <code>TreeMap&lt;K,V>::new</code></li></ul></li><li><p>배열 생성자</p><ul><li><code>len -> new int[len]</code> ⇒ <code>int[]::new</code></li></ul></li></ul><h2 id=아이템-44-표준-함수형-인터페이스를-사용하라>아이템 44: 표준 함수형 인터페이스를 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-44-표준-함수형-인터페이스를-사용하라>#</a></h2><p>자바에서는 람다에 사용할 수 있도록 다양한 모양의 표준 함수형 인터페이스를 제공하고 있다.</p><ul><li>람다에 사용하기 위해 직접 인터페이스를 구현하기보다는, 표준 함수형 인터페이스를 사용하자.</li></ul><h3 id=전용-함수형-인터페이스를-구현해야-하는-경우>전용 함수형 인터페이스를 구현해야 하는 경우<a hidden class=anchor aria-hidden=true href=#전용-함수형-인터페이스를-구현해야-하는-경우>#</a></h3><p>e.g. Comparator</p><ul><li>자주 쓰이며, 이름 자체가 용도를 명확히 설명한다.</li><li>반드시 따라야 하는 규약이 있다.</li><li>유용한 디폴트 메서드를 제공할 수 있다.</li></ul><p>직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자.</p><h2 id=아이템-45-스트림은-주의해서-사용하라>아이템 45: 스트림은 주의해서 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-45-스트림은-주의해서-사용하라>#</a></h2><p>자바 8에서 추가된 스트림은 다량의 데이터 처리 작업을 위해 도입되었다.</p><h3 id=스트림-파이프라인>스트림 파이프라인<a hidden class=anchor aria-hidden=true href=#스트림-파이프라인>#</a></h3><ul><li>스트림 파이프라인은 지연 평가된다.</li><li>평가는 종단 연산이 호출될 때 이루어지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.</li></ul><p>스트림을 잘못 사용하면 읽기 어렵고 유지보수가 힘든 코드가 만들어진다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 45-2 스트림을 과하게 사용했다. - 따라 하지 말 것! (270-271쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StreamAnagrams</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Path dictionary <span style=color:#f92672>=</span> Paths<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>args<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> minGroupSize <span style=color:#f92672>=</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>parseInt</span><span style=color:#f92672>(</span>args<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>(</span>Stream<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> words <span style=color:#f92672>=</span> Files<span style=color:#f92672>.</span><span style=color:#a6e22e>lines</span><span style=color:#f92672>(</span>dictionary<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            words<span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>                    groupingBy<span style=color:#f92672>(</span>word <span style=color:#f92672>-&gt;</span> word<span style=color:#f92672>.</span><span style=color:#a6e22e>chars</span><span style=color:#f92672>().</span><span style=color:#a6e22e>sorted</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                            <span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>StringBuilder<span style=color:#f92672>::</span><span style=color:#66d9ef>new</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>(</span>sb<span style=color:#f92672>,</span> c<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> sb<span style=color:#f92672>.</span><span style=color:#a6e22e>append</span><span style=color:#f92672>((</span><span style=color:#66d9ef>char</span><span style=color:#f92672>)</span> c<span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>                                    StringBuilder<span style=color:#f92672>::</span>append<span style=color:#f92672>).</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>()))</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>values</span><span style=color:#f92672>().</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>group <span style=color:#f92672>-&gt;</span> group<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>()</span> <span style=color:#f92672>&gt;=</span> minGroupSize<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>group <span style=color:#f92672>-&gt;</span> group<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> group<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>forEach</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>→ 도우미 메서드를 적절히 활용하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 45-3 스트림을 적절히 활용하면 깔끔하고 명료해진다. (271쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HybridAnagrams</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Path dictionary <span style=color:#f92672>=</span> Paths<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>args<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> minGroupSize <span style=color:#f92672>=</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>parseInt</span><span style=color:#f92672>(</span>args<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>(</span>Stream<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> words <span style=color:#f92672>=</span> Files<span style=color:#f92672>.</span><span style=color:#a6e22e>lines</span><span style=color:#f92672>(</span>dictionary<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            words<span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>groupingBy<span style=color:#f92672>(</span>word <span style=color:#f92672>-&gt;</span> alphabetize<span style=color:#f92672>(</span>word<span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>values</span><span style=color:#f92672>().</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>group <span style=color:#f92672>-&gt;</span> group<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>()</span> <span style=color:#f92672>&gt;=</span> minGroupSize<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span><span style=color:#a6e22e>forEach</span><span style=color:#f92672>(</span>g <span style=color:#f92672>-&gt;</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>g<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> g<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>alphabetize</span><span style=color:#f92672>(</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> a <span style=color:#f92672>=</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>toCharArray</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>sort</span><span style=color:#f92672>(</span>a<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>(</span>a<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=스트림과-람다>스트림과 람다<a hidden class=anchor aria-hidden=true href=#스트림과-람다>#</a></h3><ul><li>람다에서는 타입을 자주 생략하므로 매개변수 이름을 잘 지어야 한다.</li><li>도우미 메서드를 적절히 활용하는 일의 중요성은 일반 반복 코드보다는 스트림 파이프라인에서 훨씬 크다.</li></ul><h3 id=스트림을-쓰면-좋은-것>스트림을 쓰면 좋은 것<a hidden class=anchor aria-hidden=true href=#스트림을-쓰면-좋은-것>#</a></h3><ul><li>원소들의 시퀀스를 일관되게 변환한다.</li><li>원소들의 시퀀스를 필터링한다.</li><li>원소들의 시퀀스를 하나의 연산을 사용해 결합한다.</li><li>원소들의 시퀀스를 컬렉션에 모은다.</li><li>원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.</li></ul><h3 id=스트림람다이-할-수-없는-것>스트림(+람다)이 할 수 없는 것<a hidden class=anchor aria-hidden=true href=#스트림람다이-할-수-없는-것>#</a></h3><ul><li>람다에선 final 이거나 사실상 final인 변수만 읽을 수 있고, 지역변수를 수정할 수 없다.</li><li>람다는 흐름 제어가 불가능하지만, 코드 블록에서는 가능하다.</li></ul><blockquote><p>스트림과 반복문 중 어떤 쪽이 나은지 확신하기 어렵다면 직접 구현해 보고 나은 쪽을 선택하자.</p></blockquote><h2 id=아이템-46-스트림에서는-부작용없는-함수를-사용하라>아이템 46: 스트림에서는 부작용없는 함수를 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-46-스트림에서는-부작용없는-함수를-사용하라>#</a></h2><ul><li><p>함수형 패러다임을 지키려면 부작용없는 순수함수를 사용해야 한다.</p></li><li><p>순수함수는 입력만이 결과에 영향을 주는 함수이며, 함수 외부의 가변 상태를 참조하지 않고 외부의 상태도 변경하지 않는 함수이다.</p></li><li><p>스트림 파이프라인에 사용할 함수는 부작용이 없는 순수 함수를 사용해야 한다.</p><ul><li>forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자.</li><li>잘못된 예</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 46-1 스트림 패러다임을 이해하지 못한 채 API만 사용했다 - 따라 하지 말 것! (277쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Map<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> Long<span style=color:#f92672>&gt;</span> freq <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> <span style=color:#f92672>(</span>Stream<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> words <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner<span style=color:#f92672>(</span>file<span style=color:#f92672>).</span><span style=color:#a6e22e>tokens</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    words<span style=color:#f92672>.</span><span style=color:#a6e22e>forEach</span><span style=color:#f92672>(</span>word <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        freq<span style=color:#f92672>.</span><span style=color:#a6e22e>merge</span><span style=color:#f92672>(</span>word<span style=color:#f92672>.</span><span style=color:#a6e22e>toLowerCase</span><span style=color:#f92672>(),</span> <span style=color:#ae81ff>1L</span><span style=color:#f92672>,</span> Long<span style=color:#f92672>::</span>sum<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>좋은 예</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 46-2 스트림을 제대로 활용해 빈도표를 초기화한다. (278쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Map<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> Long<span style=color:#f92672>&gt;</span> freq<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> <span style=color:#f92672>(</span>Stream<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> words <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner<span style=color:#f92672>(</span>file<span style=color:#f92672>).</span><span style=color:#a6e22e>tokens</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    freq <span style=color:#f92672>=</span> words
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>groupingBy<span style=color:#f92672>(</span>String<span style=color:#f92672>::</span>toLowerCase<span style=color:#f92672>,</span> counting<span style=color:#f92672>()));</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></li><li><p>수집기를 사용하면 스트림의 원소를 손쉽게 컬렉션으로 모을 수 있다.</p><ul><li>toList(), toSet(), toMap() &mldr;</li></ul></li></ul><h2 id=아이템-47-반환-타입으로는-스트림보다-컬렉션이-낫다>아이템 47: 반환 타입으로는 스트림보다 컬렉션이 낫다<a hidden class=anchor aria-hidden=true href=#아이템-47-반환-타입으로는-스트림보다-컬렉션이-낫다>#</a></h2><p>스트림은 반복을 지원하지 않는다. Iterable을 사용해 우회할 수 있으나, 코드가 지저분해지고 읽기 힘들어진다.</p><ul><li>어댑터를 사용해서 Iterable ↔ Stream간 상호 변환을 간단히 구현할 수 있다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 스트림 &lt;-&gt; 반복자 어댑터 (285-286쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Adapters</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 47-3 Stream&lt;E&gt;를 Iterable&lt;E&gt;로 중개해주는 어댑터 (285쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> Iterable<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>iterableOf</span><span style=color:#f92672>(</span>Stream<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> stream<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> stream<span style=color:#f92672>::</span>iterator<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 47-4 Iterable&lt;E&gt;를 Stream&lt;E&gt;로 중개해주는 어댑터 (286쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> Stream<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>streamOf</span><span style=color:#f92672>(</span>Iterable<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> iterable<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> StreamSupport<span style=color:#f92672>.</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>(</span>iterable<span style=color:#f92672>.</span><span style=color:#a6e22e>spliterator</span><span style=color:#f92672>(),</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 하위 타입을 사용하는 것이 일반적으로 최선이다.</li><li>원소를 이미 컬렉션에 담아 관리하고 있거나 원소 개수가 적다면 표준 컬렉션에 담아서 반환하고, 그렇지 않다면 전용 컬렉션을 구현하는 것을 검토하자.</li></ul><p>→ 반환 타입은 스트림보다는, 반복과 스트림을 모두 지원할 수 있는 컬렉션 타입이 낫다.</p><h2 id=아이템-48-스트림-병렬화는-주의해서-적용하라>아이템 48: 스트림 병렬화는 주의해서 적용하라<a hidden class=anchor aria-hidden=true href=#아이템-48-스트림-병렬화는-주의해서-적용하라>#</a></h2><p>스트림은 <code>.parallel()</code> 로 쉽게 병렬화할 수 있지만, 마구잡이로 사용할 경우 오히려 성능을 해치거나, 잘못된 결과를 만들 수 있다.</p><ul><li>데이터 소스가 <code>Stream.iterate</code>거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.</li><li>대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나, 배열, IntRange, LongRange일 때 병렬화의 효과가 가장 좋다.<ul><li>데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있고, 참조 지역성이 뛰어나기 때문</li></ul></li><li>파이프라인이 수행하는 작업이 병렬화에 드는 추가 비용을 상쇄하지 못한다면 성능 향상에는 도움이 되지 않는다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junbread.win/tags/study/>Study</a></li><li><a href=https://junbread.win/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://junbread.win/posts/2021/effective-java-09/><span class=title>« Prev</span><br><span>이펙티브 자바 9장 정리</span></a>
<a class=next href=https://junbread.win/posts/2021/effective-java-06/><span class=title>Next »</span><br><span>이펙티브 자바 6장 정리</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=junbread/blog data-repo-id=R_kgDOJLcBtQ data-category=Comments data-category-id=DIC_kwDOJLcBtc4CVATm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=dark data-lang=ko data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://junbread.win>Junbread🥐</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>