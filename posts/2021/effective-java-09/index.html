<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>이펙티브 자바 9장 정리 | Junbread🥐</title><meta name=keywords content="Study,Java"><meta name=description content="아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.
지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다."><meta name=author content><link rel=canonical href=https://junbread.win/posts/2021/effective-java-09/><link crossorigin=anonymous href=/assets/css/stylesheet.f6c1b3e9443ffcf8efd37433e13b909fd545f99414f2ac3e5b22795096fc9f44.css integrity="sha256-9sGz6UQ//Pjv03Qz4TuQn9VF+ZQU8qw+WyJ5UJb8n0Q=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://junbread.win/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junbread.win/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junbread.win/favicon-32x32.png><link rel=apple-touch-icon href=https://junbread.win/apple-touch-icon.png><link rel=mask-icon href=https://junbread.win/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet type=text/css crossorigin href=//cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/variable/pretendardvariable-dynamic-subset.css><link rel=stylesheet type=text/css crossorigin href="//fonts.googleapis.com/css2?family=Source+Code+Pro"><script async src="https://www.googletagmanager.com/gtag/js?id=G-0QLLXH086F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0QLLXH086F",{anonymize_ip:!1})}</script><meta property="og:title" content="이펙티브 자바 9장 정리"><meta property="og:description" content="아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.
지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다."><meta property="og:type" content="article"><meta property="og:url" content="https://junbread.win/posts/2021/effective-java-09/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-16T00:00:00+00:00"><meta property="article:modified_time" content="2021-08-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="이펙티브 자바 9장 정리"><meta name=twitter:description content="아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.
지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://junbread.win/posts/"},{"@type":"ListItem","position":3,"name":"이펙티브 자바 9장 정리","item":"https://junbread.win/posts/2021/effective-java-09/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"이펙티브 자바 9장 정리","name":"이펙티브 자바 9장 정리","description":"아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.\n지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다.","keywords":["Study","Java"],"articleBody":"아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.\n지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다.\nIterator\u003cElement\u003e i = c.iterator(); while (i.hasNext()) { doSomething(i.next()); } for (Iterator\u003cElement\u003e i = c.iterator(); i.hasNext(); ) { Element e = i.next(); doSomething(e); } 아이템 58: 전통적인 for 문보다는 for-each 문을 사용하라 자바 1.5부터 추가된 for-each 문은 전통적인 for 문보다 깔끔하고 예상치 못한 오류를 줄여 준다.\nIterable을 구현한 객체라면 무엇이든 순회 가능하다.\nvar list = new ArrayList\u003cInteger\u003e(); for (int i = 0; i \u003c list.size(); i++) { } for (var item : list) { } for-each를 사용할 수 없는 상황 파괴적인 필터링: 컬렉션을 순회하면서 특정 원소를 제거\n자바 8부터는 Collections.removeIf()를 사용할 수 있다.\n변형: 컬렉션을 순회하면서 원소의 값 또는 전체를 교체\n병렬 반복: 컬렉션을 병렬로 순회\n아이템 59: 라이브러리를 익히고 사용하라 표준 라이브러리를 사용하면 코드를 작성한 전문가의 지식과 다른 프로그래머의 경험을 활용할 수 있다.\n→ 바퀴를 재발명하지 말자.\n아이템 60: 정확한 답이 필요하다면 float와 double은 피하라 float과 double 등의 부동 소수점 연산 타입은 정확한 값이 아닌 근사치를 사용하기 때문에, 정확한 값이 필요할 때는 사용하면 안 된다.\n→ 느리지만 정확한 값이 필요하다면 BigInteger, BigDecimal 타입을 사용하자.\n아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라 오토박싱이 지원되기 때문에 기본 타입과 참조 타입을 큰 구분없이 사용할 수 있지만, 사용에 주의해야 한다.\n기본 타입과 박싱된 기본 타입의 차이점 기본 타입은 값만 가지고 있지만, 박싱된 기본 타입은 참조 타입이기 때문에 참조 식별성이 있다.\nvar a = new Integer(1); var b = new Integer(1); a.equals(b); // true a == b; // false 박싱된 기본 타입은 null을 가질 수 있다.\n기본 타입이 박싱된 타입보다 효율적이다.\n박싱 타입은 참조 타입이기 때문에 무조건 메모리를 사용하지만, 기본 타입은 변수 자체에 값이 있다. 박싱된 타입 사용시 발생할 수 있는 상황들 박싱된 타입에서 동등성 비교를 equals() 대신 ==를 사용해서 하게 되면 정상적으로 동작하지 않는다.\n기본 타입과 박싱된 타입을 혼용한 연산에서는 대부분 언박싱되므로, NPE에 주의해야 한다.\npublic class Unbelievable { static Integer i; public static void main(String[] args) { if (i == 42) { System.out.println(\"믿을 수 없군\"); } } } 타입을 잘못 사용하게 되면 오토박싱으로 인한 성능 저하가 일어난다.\npublic static void main(String[] args) { Long sum = 0L; for (long i = 0L; i \u003c Integer.MAX_VALUE; i++) { sum += i; } System.out.println(sum); } 매개변수화 타입의 타입 매개변수로 사용할 때, 리플렉션을 사용할 때를 제외하고는 기본 타입을 사용하는 것이 낫다.\n아이템 62: 다른 타입이 적절하다면 문자열 사용을 피하라 더 적절한 타입이 있거나 새로 작성할 수 있다면 문자열을 사용하지 말고 해당 타입을 사용하자.\n다른 값 타입/열거 타입/혼합 타입을 표현하기 위해 문자열을 사용하지 말아야 한다.\n아이템 63: 문자열 연결은 느리니 주의하라 문자열은 불변이기 때문에, 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 한다.\n→ 많은 문자열을 연결할 때는 문자열 연결 연산자(+) 대신 StringBuilder를 사용하자.\n아이템 64: 객체는 인터페이스를 사용해 참조하라 인터페이스를 참조하면 프로그램이 훨씬 유연해진다.\n적합한 인터페이스가 있는 경우 매개변수, 반환값, 변수, 필드 등 객체를 참조하는 모든 곳을 인터페이스 타입으로 선언하자. 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 상위 클래스를 타입으로 사용하자. 아이템 65: 리플렉션보다는 인터페이스를 사용하라 리플렉션은 강력하지만, 장황하고 오류를 만들기 쉽기 때문에 아주 제한된 형태로만 사용해야 한다.\n리플렉션으로 인스턴스를 생성하는 경우 인터페이스나 상위 클래스로 참조해 사용하는 것이 좋다.\n리플렉션의 단점 컴파일타임 타입 검사의 이점을 누릴 수 없다. 코드가 지저분하고 장황해진다. 성능이 떨어진다. // 리플렉션으로 활용한 인스턴스화 데모 public class ReflectiveInstantiation { // 코드 65-1 리플렉션으로 생성하고 인터페이스로 참조해 활용한다. (372-373쪽) public static void main(String[] args) { // 클래스 이름을 Class 객체로 변환 Class\u003c? extends Set\u003cString\u003e\u003e cl = null; try { cl = (Class\u003c? extends Set\u003cString\u003e\u003e) // 비검사 형변환! Class.forName(args[0]); } catch (ClassNotFoundException e) { fatalError(\"클래스를 찾을 수 없습니다.\"); } // 생성자를 얻는다. Constructor\u003c? extends Set\u003cString\u003e\u003e cons = null; try { cons = cl.getDeclaredConstructor(); } catch (NoSuchMethodException e) { fatalError(\"매개변수 없는 생성자를 찾을 수 없습니다.\"); } // 집합의 인스턴스를 만든다. Set\u003cString\u003e s = null; try { s = cons.newInstance(); } catch (IllegalAccessException e) { fatalError(\"생성자에 접근할 수 없습니다.\"); } catch (InstantiationException e) { fatalError(\"클래스를 인스턴스화할 수 없습니다.\"); } catch (InvocationTargetException e) { fatalError(\"생성자가 예외를 던졌습니다: \" + e.getCause()); } catch (ClassCastException e) { fatalError(\"Set을 구현하지 않은 클래스입니다.\"); } // 생성한 집합을 사용한다. s.addAll(Arrays.asList(args).subList(1, args.length)); System.out.println(s); } private static void fatalError(String msg) { System.err.println(msg); System.exit(1); } } 아이템 66: 네이티브 메서드는 신중히 사용하라 자바는 JNI를 통해 네이티브 코드에 접근할 수 있지만, 사용에 신중해야 한다.\n네이티브 메서드가 성능을 개선하는 일은 많지 않으며, 디버깅 용이성과 이식성을 저하시킨다. 네이티브 코드는 안전하지 않기 때문에 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않다. 아이템 67: 최적화는 신중히 하라 빠른 프로그램보다는 좋은 프로그램이 낫다. 성능을 제한하는 설계를 피하라. API를 설계할 때 성능에 주는 영향을 고려하라. 하지만 성능을 위해 API를 왜곡하면 안 된다. 최적화 시도 전후로 성능을 측정하자. 아이템 68: 일반적으로 통용되는 명명 규칙을 따르라 표준 명명 규칙을 습관화하자.\n","wordCount":"811","inLanguage":"en","datePublished":"2021-08-16T00:00:00Z","dateModified":"2021-08-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://junbread.win/posts/2021/effective-java-09/"},"publisher":{"@type":"Organization","name":"Junbread🥐","logo":{"@type":"ImageObject","url":"https://junbread.win/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junbread.win accesskey=h title="Junbread🥐 (Alt + H)">Junbread🥐</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://junbread.win/about title=About><span>About</span></a></li><li><a href=https://junbread.win/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://junbread.win/tags/ title=태그><span>태그</span></a></li><li><a href=https://junbread.win/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://junbread.win>Home</a>&nbsp;»&nbsp;<a href=https://junbread.win/posts/>Posts</a></div><h1 class=post-title>이펙티브 자바 9장 정리</h1><div class=post-meta><span title='2021-08-16 00:00:00 +0000 UTC'>August 16, 2021</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-57-%ec%a7%80%ec%97%ad%eb%b3%80%ec%88%98%ec%9d%98-%eb%b2%94%ec%9c%84%eb%a5%bc-%ec%b5%9c%ec%86%8c%ed%99%94%ed%95%98%eb%9d%bc aria-label="아이템 57: 지역변수의 범위를 최소화하라">아이템 57: 지역변수의 범위를 최소화하라</a><ul><li><a href=#%ec%a7%80%ec%97%ad%eb%b3%80%ec%88%98-%ec%b4%88%ea%b8%b0%ed%99%94-%ec%8b%9c%ec%a0%90 aria-label="지역변수 초기화 시점">지역변수 초기화 시점</a></li><li><a href=#%eb%b0%98%eb%b3%b5%eb%ac%b8%ec%9d%80-while-%eb%ac%b8%eb%b3%b4%eb%8b%a4%eb%8a%94-for-%eb%ac%b8%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%ec%9e%90 aria-label="반복문은 while 문보다는 for 문을 사용하자">반복문은 while 문보다는 for 문을 사용하자</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-58-%ec%a0%84%ed%86%b5%ec%a0%81%ec%9d%b8-for-%eb%ac%b8%eb%b3%b4%eb%8b%a4%eb%8a%94-for-each-%eb%ac%b8%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 58: 전통적인 for 문보다는 for-each 문을 사용하라">아이템 58: 전통적인 for 문보다는 for-each 문을 사용하라</a><ul><li><a href=#for-each%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%a0-%ec%88%98-%ec%97%86%eb%8a%94-%ec%83%81%ed%99%a9 aria-label="for-each를 사용할 수 없는 상황">for-each를 사용할 수 없는 상황</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-59-%eb%9d%bc%ec%9d%b4%eb%b8%8c%eb%9f%ac%eb%a6%ac%eb%a5%bc-%ec%9d%b5%ed%9e%88%ea%b3%a0-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 59: 라이브러리를 익히고 사용하라">아이템 59: 라이브러리를 익히고 사용하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-60-%ec%a0%95%ed%99%95%ed%95%9c-%eb%8b%b5%ec%9d%b4-%ed%95%84%ec%9a%94%ed%95%98%eb%8b%a4%eb%a9%b4-float%ec%99%80-double%ec%9d%80-%ed%94%bc%ed%95%98%eb%9d%bc aria-label="아이템 60: 정확한 답이 필요하다면 float와 double은 피하라">아이템 60: 정확한 답이 필요하다면 float와 double은 피하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-61-%eb%b0%95%ec%8b%b1%eb%90%9c-%ea%b8%b0%eb%b3%b8-%ed%83%80%ec%9e%85%eb%b3%b4%eb%8b%a4%eb%8a%94-%ea%b8%b0%eb%b3%b8-%ed%83%80%ec%9e%85%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라">아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라</a><ul><li><a href=#%ea%b8%b0%eb%b3%b8-%ed%83%80%ec%9e%85%ea%b3%bc-%eb%b0%95%ec%8b%b1%eb%90%9c-%ea%b8%b0%eb%b3%b8-%ed%83%80%ec%9e%85%ec%9d%98-%ec%b0%a8%ec%9d%b4%ec%a0%90 aria-label="기본 타입과 박싱된 기본 타입의 차이점">기본 타입과 박싱된 기본 타입의 차이점</a></li><li><a href=#%eb%b0%95%ec%8b%b1%eb%90%9c-%ed%83%80%ec%9e%85-%ec%82%ac%ec%9a%a9%ec%8b%9c-%eb%b0%9c%ec%83%9d%ed%95%a0-%ec%88%98-%ec%9e%88%eb%8a%94-%ec%83%81%ed%99%a9%eb%93%a4 aria-label="박싱된 타입 사용시 발생할 수 있는 상황들">박싱된 타입 사용시 발생할 수 있는 상황들</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-62-%eb%8b%a4%eb%a5%b8-%ed%83%80%ec%9e%85%ec%9d%b4-%ec%a0%81%ec%a0%88%ed%95%98%eb%8b%a4%eb%a9%b4-%eb%ac%b8%ec%9e%90%ec%97%b4-%ec%82%ac%ec%9a%a9%ec%9d%84-%ed%94%bc%ed%95%98%eb%9d%bc aria-label="아이템 62: 다른 타입이 적절하다면 문자열 사용을 피하라">아이템 62: 다른 타입이 적절하다면 문자열 사용을 피하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-63-%eb%ac%b8%ec%9e%90%ec%97%b4-%ec%97%b0%ea%b2%b0%ec%9d%80-%eb%8a%90%eb%a6%ac%eb%8b%88-%ec%a3%bc%ec%9d%98%ed%95%98%eb%9d%bc aria-label="아이템 63: 문자열 연결은 느리니 주의하라">아이템 63: 문자열 연결은 느리니 주의하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-64-%ea%b0%9d%ec%b2%b4%eb%8a%94-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%b4-%ec%b0%b8%ec%a1%b0%ed%95%98%eb%9d%bc aria-label="아이템 64: 객체는 인터페이스를 사용해 참조하라">아이템 64: 객체는 인터페이스를 사용해 참조하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-65-%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%eb%b3%b4%eb%8b%a4%eb%8a%94-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 65: 리플렉션보다는 인터페이스를 사용하라">아이템 65: 리플렉션보다는 인터페이스를 사용하라</a><ul><li><a href=#%eb%a6%ac%ed%94%8c%eb%a0%89%ec%85%98%ec%9d%98-%eb%8b%a8%ec%a0%90 aria-label="리플렉션의 단점">리플렉션의 단점</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-66-%eb%84%a4%ec%9d%b4%ed%8b%b0%eb%b8%8c-%eb%a9%94%ec%84%9c%eb%93%9c%eb%8a%94-%ec%8b%a0%ec%a4%91%ed%9e%88-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 66: 네이티브 메서드는 신중히 사용하라">아이템 66: 네이티브 메서드는 신중히 사용하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-67-%ec%b5%9c%ec%a0%81%ed%99%94%eb%8a%94-%ec%8b%a0%ec%a4%91%ed%9e%88-%ed%95%98%eb%9d%bc aria-label="아이템 67: 최적화는 신중히 하라">아이템 67: 최적화는 신중히 하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-68-%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9c%bc%eb%a1%9c-%ed%86%b5%ec%9a%a9%eb%90%98%eb%8a%94-%eb%aa%85%eb%aa%85-%ea%b7%9c%ec%b9%99%ec%9d%84-%eb%94%b0%eb%a5%b4%eb%9d%bc aria-label="아이템 68: 일반적으로 통용되는 명명 규칙을 따르라">아이템 68: 일반적으로 통용되는 명명 규칙을 따르라</a></li></ul></div></details></div><div class=post-content><h2 id=아이템-57-지역변수의-범위를-최소화하라>아이템 57: 지역변수의 범위를 최소화하라<a hidden class=anchor aria-hidden=true href=#아이템-57-지역변수의-범위를-최소화하라>#</a></h2><p>자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.</p><h3 id=지역변수-초기화-시점>지역변수 초기화 시점<a hidden class=anchor aria-hidden=true href=#지역변수-초기화-시점>#</a></h3><ul><li>거의 모든 지역변수는 선언과 동시에 초기화해야 한다.</li><li>예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다.</li></ul><h3 id=반복문은-while-문보다는-for-문을-사용하자>반복문은 while 문보다는 for 문을 사용하자<a hidden class=anchor aria-hidden=true href=#반복문은-while-문보다는-for-문을-사용하자>#</a></h3><p>→ while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Iterator<span style=color:#f92672>&lt;</span>Element<span style=color:#f92672>&gt;</span> i <span style=color:#f92672>=</span> c<span style=color:#f92672>.</span><span style=color:#a6e22e>iterator</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>i<span style=color:#f92672>.</span><span style=color:#a6e22e>hasNext</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    doSomething<span style=color:#f92672>(</span>i<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Iterator<span style=color:#f92672>&lt;</span>Element<span style=color:#f92672>&gt;</span> i <span style=color:#f92672>=</span> c<span style=color:#f92672>.</span><span style=color:#a6e22e>iterator</span><span style=color:#f92672>();</span> i<span style=color:#f92672>.</span><span style=color:#a6e22e>hasNext</span><span style=color:#f92672>();</span> <span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Element e <span style=color:#f92672>=</span> i<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>	  doSomething<span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=아이템-58-전통적인-for-문보다는-for-each-문을-사용하라>아이템 58: 전통적인 for 문보다는 for-each 문을 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-58-전통적인-for-문보다는-for-each-문을-사용하라>#</a></h2><p>자바 1.5부터 추가된 for-each 문은 전통적인 for 문보다 깔끔하고 예상치 못한 오류를 줄여 준다.</p><p>Iterable을 구현한 객체라면 무엇이든 순회 가능하다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>var list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;();</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>var item <span style=color:#f92672>:</span> list<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=for-each를-사용할-수-없는-상황>for-each를 사용할 수 없는 상황<a hidden class=anchor aria-hidden=true href=#for-each를-사용할-수-없는-상황>#</a></h3><ul><li><p>파괴적인 필터링: 컬렉션을 순회하면서 특정 원소를 제거</p><p>자바 8부터는 <code>Collections.removeIf()</code>를 사용할 수 있다.</p></li><li><p>변형: 컬렉션을 순회하면서 원소의 값 또는 전체를 교체</p></li><li><p>병렬 반복: 컬렉션을 병렬로 순회</p></li></ul><h2 id=아이템-59-라이브러리를-익히고-사용하라>아이템 59: 라이브러리를 익히고 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-59-라이브러리를-익히고-사용하라>#</a></h2><p>표준 라이브러리를 사용하면 코드를 작성한 전문가의 지식과 다른 프로그래머의 경험을 활용할 수 있다.</p><p>→ 바퀴를 재발명하지 말자.</p><h2 id=아이템-60-정확한-답이-필요하다면-float와-double은-피하라>아이템 60: 정확한 답이 필요하다면 float와 double은 피하라<a hidden class=anchor aria-hidden=true href=#아이템-60-정확한-답이-필요하다면-float와-double은-피하라>#</a></h2><p>float과 double 등의 부동 소수점 연산 타입은 정확한 값이 아닌 <strong>근사치</strong>를 사용하기 때문에, 정확한 값이 필요할 때는 사용하면 안 된다.</p><p>→ 느리지만 정확한 값이 필요하다면 BigInteger, BigDecimal 타입을 사용하자.</p><h2 id=아이템-61-박싱된-기본-타입보다는-기본-타입을-사용하라>아이템 61: 박싱된 기본 타입보다는 기본 타입을 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-61-박싱된-기본-타입보다는-기본-타입을-사용하라>#</a></h2><p>오토박싱이 지원되기 때문에 기본 타입과 참조 타입을 큰 구분없이 사용할 수 있지만, 사용에 주의해야 한다.</p><h3 id=기본-타입과-박싱된-기본-타입의-차이점>기본 타입과 박싱된 기본 타입의 차이점<a hidden class=anchor aria-hidden=true href=#기본-타입과-박싱된-기본-타입의-차이점>#</a></h3><ul><li><p>기본 타입은 값만 가지고 있지만, 박싱된 기본 타입은 참조 타입이기 때문에 참조 식별성이 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>var a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Integer<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>var b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Integer<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>b<span style=color:#f92672>);</span> <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>a <span style=color:#f92672>==</span> b<span style=color:#f92672>;</span> <span style=color:#75715e>// false
</span></span></span></code></pre></div></li><li><p>박싱된 기본 타입은 null을 가질 수 있다.</p></li><li><p>기본 타입이 박싱된 타입보다 효율적이다.</p><ul><li>박싱 타입은 참조 타입이기 때문에 무조건 메모리를 사용하지만, 기본 타입은 변수 자체에 값이 있다.</li></ul></li></ul><h3 id=박싱된-타입-사용시-발생할-수-있는-상황들>박싱된 타입 사용시 발생할 수 있는 상황들<a hidden class=anchor aria-hidden=true href=#박싱된-타입-사용시-발생할-수-있는-상황들>#</a></h3><ul><li><p>박싱된 타입에서 동등성 비교를 <code>equals()</code> 대신 <code>==</code>를 사용해서 하게 되면 정상적으로 동작하지 않는다.</p></li><li><p>기본 타입과 박싱된 타입을 혼용한 연산에서는 대부분 언박싱되므로, NPE에 주의해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Unbelievable</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Integer i<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>i <span style=color:#f92672>==</span> <span style=color:#ae81ff>42</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;믿을 수 없군&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></li><li><p>타입을 잘못 사용하게 되면 오토박싱으로 인한 성능 저하가 일어난다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Long sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>L<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>L<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>MAX_VALUE</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> i<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>sum<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></li></ul><p>매개변수화 타입의 타입 매개변수로 사용할 때, 리플렉션을 사용할 때를 제외하고는 기본 타입을 사용하는 것이 낫다.</p><h2 id=아이템-62-다른-타입이-적절하다면-문자열-사용을-피하라>아이템 62: 다른 타입이 적절하다면 문자열 사용을 피하라<a hidden class=anchor aria-hidden=true href=#아이템-62-다른-타입이-적절하다면-문자열-사용을-피하라>#</a></h2><p>더 적절한 타입이 있거나 새로 작성할 수 있다면 문자열을 사용하지 말고 해당 타입을 사용하자.</p><p>다른 값 타입/열거 타입/혼합 타입을 표현하기 위해 문자열을 사용하지 말아야 한다.</p><h2 id=아이템-63-문자열-연결은-느리니-주의하라>아이템 63: 문자열 연결은 느리니 주의하라<a hidden class=anchor aria-hidden=true href=#아이템-63-문자열-연결은-느리니-주의하라>#</a></h2><p>문자열은 불변이기 때문에, 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 한다.</p><p>→ 많은 문자열을 연결할 때는 문자열 연결 연산자(+) 대신 StringBuilder를 사용하자.</p><h2 id=아이템-64-객체는-인터페이스를-사용해-참조하라>아이템 64: 객체는 인터페이스를 사용해 참조하라<a hidden class=anchor aria-hidden=true href=#아이템-64-객체는-인터페이스를-사용해-참조하라>#</a></h2><p>인터페이스를 참조하면 프로그램이 훨씬 유연해진다.</p><ul><li>적합한 인터페이스가 있는 경우 매개변수, 반환값, 변수, 필드 등 객체를 참조하는 모든 곳을 인터페이스 타입으로 선언하자.</li><li>적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 상위 클래스를 타입으로 사용하자.</li></ul><h2 id=아이템-65-리플렉션보다는-인터페이스를-사용하라>아이템 65: 리플렉션보다는 인터페이스를 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-65-리플렉션보다는-인터페이스를-사용하라>#</a></h2><p>리플렉션은 강력하지만, 장황하고 오류를 만들기 쉽기 때문에 아주 제한된 형태로만 사용해야 한다.</p><p>리플렉션으로 인스턴스를 생성하는 경우 인터페이스나 상위 클래스로 참조해 사용하는 것이 좋다.</p><h3 id=리플렉션의-단점>리플렉션의 단점<a hidden class=anchor aria-hidden=true href=#리플렉션의-단점>#</a></h3><ul><li>컴파일타임 타입 검사의 이점을 누릴 수 없다.</li><li>코드가 지저분하고 장황해진다.</li><li>성능이 떨어진다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 리플렉션으로 활용한 인스턴스화 데모
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReflectiveInstantiation</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 코드 65-1 리플렉션으로 생성하고 인터페이스로 참조해 활용한다. (372-373쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 클래스 이름을 Class 객체로 변환
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> cl <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            cl <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;)</span>  <span style=color:#75715e>// 비검사 형변환!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    Class<span style=color:#f92672>.</span><span style=color:#a6e22e>forName</span><span style=color:#f92672>(</span>args<span style=color:#f92672>[</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassNotFoundException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            fatalError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;클래스를 찾을 수 없습니다.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 생성자를 얻는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Constructor<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> cons <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            cons <span style=color:#f92672>=</span> cl<span style=color:#f92672>.</span><span style=color:#a6e22e>getDeclaredConstructor</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>NoSuchMethodException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            fatalError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;매개변수 없는 생성자를 찾을 수 없습니다.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 집합의 인스턴스를 만든다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> s <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            s <span style=color:#f92672>=</span> cons<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IllegalAccessException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            fatalError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;생성자에 접근할 수 없습니다.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InstantiationException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            fatalError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;클래스를 인스턴스화할 수 없습니다.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InvocationTargetException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            fatalError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;생성자가 예외를 던졌습니다: &#34;</span> <span style=color:#f92672>+</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getCause</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassCastException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            fatalError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Set을 구현하지 않은 클래스입니다.&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 생성한 집합을 사용한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        s<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span>args<span style=color:#f92672>).</span><span style=color:#a6e22e>subList</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> args<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>s<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fatalError</span><span style=color:#f92672>(</span>String msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>err</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>exit</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=아이템-66-네이티브-메서드는-신중히-사용하라>아이템 66: 네이티브 메서드는 신중히 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-66-네이티브-메서드는-신중히-사용하라>#</a></h2><p>자바는 JNI를 통해 네이티브 코드에 접근할 수 있지만, 사용에 신중해야 한다.</p><ul><li>네이티브 메서드가 성능을 개선하는 일은 많지 않으며, 디버깅 용이성과 이식성을 저하시킨다.</li><li>네이티브 코드는 안전하지 않기 때문에 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않다.</li></ul><h2 id=아이템-67-최적화는-신중히-하라>아이템 67: 최적화는 신중히 하라<a hidden class=anchor aria-hidden=true href=#아이템-67-최적화는-신중히-하라>#</a></h2><ul><li>빠른 프로그램보다는 좋은 프로그램이 낫다.</li><li>성능을 제한하는 설계를 피하라.</li><li>API를 설계할 때 성능에 주는 영향을 고려하라.<ul><li>하지만 성능을 위해 API를 왜곡하면 안 된다.</li></ul></li><li>최적화 시도 전후로 성능을 측정하자.</li></ul><h2 id=아이템-68-일반적으로-통용되는-명명-규칙을-따르라>아이템 68: 일반적으로 통용되는 명명 규칙을 따르라<a hidden class=anchor aria-hidden=true href=#아이템-68-일반적으로-통용되는-명명-규칙을-따르라>#</a></h2><p>표준 명명 규칙을 습관화하자.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://junbread.win/tags/study/>Study</a></li><li><a href=https://junbread.win/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://junbread.win/posts/2021/effective-java-08/><span class=title>« Prev</span><br><span>이펙티브 자바 8장 정리</span></a>
<a class=next href=https://junbread.win/posts/2021/effective-java-07/><span class=title>Next »</span><br><span>이펙티브 자바 7장 정리</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=junbread/blog data-repo-id=R_kgDOJLcBtQ data-category=Comments data-category-id=DIC_kwDOJLcBtc4CVATm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=dark data-lang=ko data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://junbread.win>Junbread🥐</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>