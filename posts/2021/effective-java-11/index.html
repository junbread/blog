<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>이펙티브 자바 11장 정리 | Junbread🥐</title><meta name=keywords content="Study,Java"><meta name=description content="아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.
// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다."><meta name=author content><link rel=canonical href=https://junbread.win/posts/2021/effective-java-11/><link crossorigin=anonymous href=/assets/css/stylesheet.f6c1b3e9443ffcf8efd37433e13b909fd545f99414f2ac3e5b22795096fc9f44.css integrity="sha256-9sGz6UQ//Pjv03Qz4TuQn9VF+ZQU8qw+WyJ5UJb8n0Q=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://junbread.win/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://junbread.win/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://junbread.win/favicon-32x32.png><link rel=apple-touch-icon href=https://junbread.win/apple-touch-icon.png><link rel=mask-icon href=https://junbread.win/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet type=text/css crossorigin href=//cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.6/dist/web/variable/pretendardvariable-dynamic-subset.css><link rel=stylesheet type=text/css crossorigin href="//fonts.googleapis.com/css2?family=Source+Code+Pro"><script async src="https://www.googletagmanager.com/gtag/js?id=G-0QLLXH086F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0QLLXH086F",{anonymize_ip:!1})}</script><meta property="og:title" content="이펙티브 자바 11장 정리"><meta property="og:description" content="아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.
// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다."><meta property="og:type" content="article"><meta property="og:url" content="https://junbread.win/posts/2021/effective-java-11/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-16T00:00:00+00:00"><meta property="article:modified_time" content="2021-08-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="이펙티브 자바 11장 정리"><meta name=twitter:description content="아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.
// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://junbread.win/posts/"},{"@type":"ListItem","position":3,"name":"이펙티브 자바 11장 정리","item":"https://junbread.win/posts/2021/effective-java-11/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"이펙티브 자바 11장 정리","name":"이펙티브 자바 11장 정리","description":"아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.\n// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다.","keywords":["Study","Java"],"articleBody":"아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.\n// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u003e { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다. 컴파일러 최적화 수행 결과 의도하지 않은 대로 동작할 수도 있다. 멀티 스레드 환경에서 가변 공유 데이터를 다루는 방법 멀티스레드에서 가변 데이터를 공유하지 말자. (최선) → synchronized 를 사용해 동기화하자.\n동기화 시에는 읽기와 쓰기 모두를 동기화해야 한다.\nprivate static boolean stopRequested; private static synchronized void requestStop() { stopRequested = true; } private static synchronized boolean stopRequested() { return stopRequested; } → volatile 을 사용하면 항상 가장 최근에 기록된 값을 읽도록 보증한다. (메모리 접근)\nprivate static volatile boolean stopRequested; 하지만 원자적이지 않은 연산 수행 시에는 동기화해야 하며, 하지 않을 경우 안전 실패가 발생할 가능성이 있다. → java.util.concurrent에서 제공하는 Atomic* 자료구조를 사용하면, 동기화 락 없이도 스레드 안전하게 구현이 가능하다.\n아이템 79: 과도한 동기화는 피하라 너무 과한 동기화는 성능을 떨어뜨리고 데드락을 유발하거나, 안전 실패의 원인이 된다.\n응답 불가나 안전 실패를 피하려면 동기화 메서드나 동기화 블럭 안에서는 제어를 클라이언트에 양도해서는 안된다.\n외계인(?) 메서드\n// 코드 79-1 잘못된 코드. 동기화 블록 안에서 외계인 메서드를 호출한다. (420쪽) private final List\u003cSetObserver\u003cE\u003e\u003e observers = new ArrayList\u003c\u003e(); public void addObserver(SetObserver\u003cE\u003e observer) { synchronized(observers) { observers.add(observer); } } public boolean removeObserver(SetObserver\u003cE\u003e observer) { synchronized(observers) { return observers.remove(observer); } } private void notifyElementAdded(E element) { synchronized(observers) { for (SetObserver\u003cE\u003e observer : observers) observer.added(this, element); } } ... public class Test2 { public static void main(String[] args) { ObservableSet\u003cInteger\u003e set = new ObservableSet\u003c\u003e(new HashSet\u003c\u003e()); set.addObserver(new SetObserver\u003c\u003e() { public void added(ObservableSet\u003cInteger\u003e s, Integer e) { System.out.println(e); if (e == 23) // 값이 23이면 자신을 구독해지한다. s.removeObserver(this); } }); for (int i = 0; i \u003c 100; i++) set.add(i); } } 테스트 실행 시 ConcurrentModificationException 발생!\n→ 동기화 블럭 안에서 클라이언트 메서드가 호출되었기 때문에 synchronized의 보호를 받지 못한다.\n// 코드 79-3 외계인 메서드를 동기화 블록 바깥으로 옮겼다. - 열린 호출 (424쪽) private void notifyElementAdded(E element) { List\u003cSetObserver\u003cE\u003e\u003e snapshot = null; synchronized(observers) { snapshot = new ArrayList\u003c\u003e(observers); } for (SetObserver\u003cE\u003e observer : snapshot) observer.added(this, element); } // 코드 79-4 CopyOnWriteArrayList를 사용해 구현한 스레드 안전하고 관찰 가능한 집합 (425쪽) private final List\u003cSetObserver\u003cE\u003e\u003e observers = new CopyOnWriteArrayList\u003c\u003e(); public void addObserver(SetObserver\u003cE\u003e observer) { observers.add(observer); } public boolean removeObserver(SetObserver\u003cE\u003e observer) { return observers.remove(observer); } private void notifyElementAdded(E element) { for (SetObserver\u003cE\u003e observer : observers) observer.added(this, element); } @Override public boolean add(E element) { boolean added = super.add(element); if (added) notifyElementAdded(element); return added; } @Override public boolean addAll(Collection\u003c? extends E\u003e c) { boolean result = false; for (E element : c) result |= add(element); // notifyElementAdded를 호출한다. return result; } 동기화 영역은 최대한 작게 가져가자.\n합당한 이유가 있을 때만 내부에서 동기화하고, 동기화 여부를 문서에 명확히 밝히자.\n아이템 80: 스레드보다는 실행자, 태스크, 스트림을 애용하라 작업 큐를 만들기 위해 스레드를 직접 다루기보다는 java.util.concurrent 하위의 실행자 프레임워크를 이용하자.\nExecutorService exec = Executors.newSingleThreadExecutor(); exec.execute(runnable); exec.shutdown(); 실행자 프레임워크의 기능 특정 태스크 완료 대기 태스크 모음 중 아무거나 하나, 혹은 모든 태스크 완료 대기 실행자 서비스 종료 대기 완료된 태스크의 결과를 차례로 받기 태스크를 특정 시간, 혹은 주기로 실행하기 프로그램 규모에 따라 각각 다른 스레드 관리 메커니즘을 사용하는 실행자 서비스를 생성할 수 있다.\nex) Executors.newCachedThreadPool, Executors.newFixedThreadPool, …\n자바 7부터는 ForkJoinPool을 지원하도록 개량되어서 효율성이 개선되었다.\n아이템 81: wait과 notify보다는 동시성 유틸리티를 애용하라 wait과 notify는 올바르게 사용하기 매우 어려우므로, 고수준 동시성 유틸리티를 사용하는 것이 좋다.\n고수준 동시성 유틸리티의 종류 실행자 프레임워크 동시성 컬렉션 ConcurrentHashMap 등 내부에서 동기화를 효율적으로 구현한 컬렉션 상태 의존적 메서드들이 추가되어 있음 ex) putIfAbsent 동기화 장치 CountDownLatch, Semaphore, … // 코드 81-3 동시 실행 시간을 재는 간단한 프레임워크 (433-434쪽) public class ConcurrentTimer { private ConcurrentTimer() { } // 인스턴스 생성 불가 public static long time(Executor executor, int concurrency, Runnable action) throws InterruptedException { CountDownLatch ready = new CountDownLatch(concurrency); CountDownLatch start = new CountDownLatch(1); CountDownLatch done = new CountDownLatch(concurrency); for (int i = 0; i \u003c concurrency; i++) { executor.execute(() -\u003e { ready.countDown(); // 타이머에게 준비를 마쳤음을 알린다. try { start.await(); // 모든 작업자 스레드가 준비될 때까지 기다린다. action.run(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { done.countDown(); // 타이머에게 작업을 마쳤음을 알린다. } }); } ready.await(); // 모든 작업자가 준비될 때까지 기다린다. long startNanos = System.nanoTime(); start.countDown(); // 작업자들을 깨운다. done.await(); // 모든 작업자가 일을 끝마치기를 기다린다. return System.nanoTime() - startNanos; } } 어쩔 수 없이 wait/notify를 사용해야 할 때에는 wait 호출 시 while 문 안에서만 호출하는 표준 방식을 따르자.\nsynchronized (obj) { while (\u003c조건이 충족되지 않았다\u003e) obj.wait(); // (락을 놓고, 깨어나면 다시 잡는다.) ... // 조건이 충족됐을 때의 동작을 수행한다. } 아이템 82: 스레드 안전성 수준을 문서화하라 멀티스레드 환경에서 API를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 명시해야 한다.\\\n스레드 안전성 수준 불변 무조건적 스레드 안전: 수정될 수 있으나 내부에서 동기화해서 별도의 처리 없이 스레드 안전하게 사용 가능하다. 조건부 스레드 안전: 일부 스레드를 사용하려면 외부 동기화가 필요하다. 스레드 안전하지 않음: 동시에 사용하기 위해서는 외부 동기화가 필요하다. 스레드 적대적: 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다. (정적 데이터를 동기화 없이 수정하는 경우) 조건부 스레드 안전한 클래스는 주의해서 어떤 순서로 호출할 때 동기화 로직이 필요한지, 어떤 락을 얻어야 하는지 기술해야 한다.\n공개된 락을 사용하는 경우 클라이언트에서 락을 풀지 않는 서비스 거부 공격을 할 수 있기 때문에, 비공개 락 객체를 사용하고 final로 선언하는 것이 좋다.\n아이템 83: 지연 초기화는 신중히 사용하라 상황에 따라 지연 초기화는 오히려 성능을 더 느리게 만들 수 있으므로 신중히 사용해야 한다.\n대부분의 상황에서는 일반적인 초기화가 좋다.\n멀티스레드 환경에서의 지연 초기화 지연 초기화가 초기화 순환성을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자.\n// 코드 83-2 인스턴스 필드의 지연 초기화 - synchronized 접근자 방식 (443쪽) private FieldType field2; private synchronized FieldType getField2() { if (field2 == null) field2 = computeFieldValue(); return field2; } 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.\n// 코드 83-3 정적 필드용 지연 초기화 홀더 클래스 관용구 (443쪽) private static class FieldHolder { static final FieldType field = computeFieldValue(); } private static FieldType getField() { return FieldHolder.field; } 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중 검사 관용구를 사용하자.\n→ 이미 초기화된 경우 synchronized 블럭에 진입하지 않아서 접근 비용이 작아진다.\n// 코드 83-4 인스턴스 필드 지연 초기화용 이중검사 관용구 (444쪽) private volatile FieldType field4; private FieldType getField4() { FieldType result = field4; if (result != null) // 첫 번째 검사 (락 사용 안 함) return result; synchronized(this) { if (field4 == null) // 두 번째 검사 (락 사용) field4 = computeFieldValue(); return field4; } } 반복해서 초기화해도 상관없는 경우 동기화 없이 단일 검사해도 괜찮다.\n아이템 84: 프로그램의 동작을 스레드 스케줄러에 기대지 말라 스레드 스케줄러의 동작은 플랫폼, 운영체제마다 다르기 때문에 다른 플랫폼에 이식하기 어려워질 수 있다.\n실행 가능한 스레드의 수가 프로세스의 수보다 과도하게 많아서는 안 된다.\n스레드는 당장 처리해야 할 작업이 없다면 실행되어서는 안 된다.\n스레드는 절대 바쁜 대기 상태가 되어서는 안 된다.\n// 코드 84-1 끔찍한 CountDownLatch 구현 - 바쁜 대기 버전! (447쪽) public class SlowCountDownLatch { private int count; public SlowCountDownLatch(int count) { if (count \u003c 0) throw new IllegalArgumentException(count + \" \u003c 0\"); this.count = count; } public void await() { while (true) { synchronized(this) { if (count == 0) return; } } } public synchronized void countDown() { if (count != 0) count--; } → 이 문제를 고친답시고 Thread.yield 등을 사용한다면 JVM 구현체별로 다른 효과에 이식성만 나빠지는 결과를 초래할 수 있다.\n","wordCount":"1232","inLanguage":"en","datePublished":"2021-08-16T00:00:00Z","dateModified":"2021-08-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://junbread.win/posts/2021/effective-java-11/"},"publisher":{"@type":"Organization","name":"Junbread🥐","logo":{"@type":"ImageObject","url":"https://junbread.win/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://junbread.win accesskey=h title="Junbread🥐 (Alt + H)">Junbread🥐</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://junbread.win/about title=About><span>About</span></a></li><li><a href=https://junbread.win/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://junbread.win/tags/ title=태그><span>태그</span></a></li><li><a href=https://junbread.win/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://junbread.win>Home</a>&nbsp;»&nbsp;<a href=https://junbread.win/posts/>Posts</a></div><h1 class=post-title>이펙티브 자바 11장 정리</h1><div class=post-meta><span title='2021-08-16 00:00:00 +0000 UTC'>August 16, 2021</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-78-%ea%b3%b5%ec%9c%a0-%ec%a4%91%ec%9d%b8-%ea%b0%80%eb%b3%80-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%8a%94-%eb%8f%99%ea%b8%b0%ed%99%94%ed%95%b4-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라">아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라</a><ul><li><a href=#%eb%a9%80%ed%8b%b0-%ec%8a%a4%eb%a0%88%eb%93%9c-%ed%99%98%ea%b2%bd%ec%97%90%ec%84%9c-%ea%b0%80%eb%b3%80-%ea%b3%b5%ec%9c%a0-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%a5%bc-%eb%8b%a4%eb%a3%a8%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="멀티 스레드 환경에서 가변 공유 데이터를 다루는 방법">멀티 스레드 환경에서 가변 공유 데이터를 다루는 방법</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-79-%ea%b3%bc%eb%8f%84%ed%95%9c-%eb%8f%99%ea%b8%b0%ed%99%94%eb%8a%94-%ed%94%bc%ed%95%98%eb%9d%bc aria-label="아이템 79: 과도한 동기화는 피하라">아이템 79: 과도한 동기화는 피하라</a></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-80-%ec%8a%a4%eb%a0%88%eb%93%9c%eb%b3%b4%eb%8b%a4%eb%8a%94-%ec%8b%a4%ed%96%89%ec%9e%90-%ed%83%9c%ec%8a%a4%ed%81%ac-%ec%8a%a4%ed%8a%b8%eb%a6%bc%ec%9d%84-%ec%95%a0%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 80: 스레드보다는 실행자, 태스크, 스트림을 애용하라">아이템 80: 스레드보다는 실행자, 태스크, 스트림을 애용하라</a><ul><li><a href=#%ec%8b%a4%ed%96%89%ec%9e%90-%ed%94%84%eb%a0%88%ec%9e%84%ec%9b%8c%ed%81%ac%ec%9d%98-%ea%b8%b0%eb%8a%a5 aria-label="실행자 프레임워크의 기능">실행자 프레임워크의 기능</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-81-wait%ea%b3%bc-notify%eb%b3%b4%eb%8b%a4%eb%8a%94-%eb%8f%99%ec%8b%9c%ec%84%b1-%ec%9c%a0%ed%8b%b8%eb%a6%ac%ed%8b%b0%eb%a5%bc-%ec%95%a0%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 81: wait과 notify보다는 동시성 유틸리티를 애용하라">아이템 81: wait과 notify보다는 동시성 유틸리티를 애용하라</a><ul><li><a href=#%ea%b3%a0%ec%88%98%ec%a4%80-%eb%8f%99%ec%8b%9c%ec%84%b1-%ec%9c%a0%ed%8b%b8%eb%a6%ac%ed%8b%b0%ec%9d%98-%ec%a2%85%eb%a5%98 aria-label="고수준 동시성 유틸리티의 종류">고수준 동시성 유틸리티의 종류</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-82-%ec%8a%a4%eb%a0%88%eb%93%9c-%ec%95%88%ec%a0%84%ec%84%b1-%ec%88%98%ec%a4%80%ec%9d%84-%eb%ac%b8%ec%84%9c%ed%99%94%ed%95%98%eb%9d%bc aria-label="아이템 82: 스레드 안전성 수준을 문서화하라">아이템 82: 스레드 안전성 수준을 문서화하라</a><ul><li><a href=#%ec%8a%a4%eb%a0%88%eb%93%9c-%ec%95%88%ec%a0%84%ec%84%b1-%ec%88%98%ec%a4%80 aria-label="스레드 안전성 수준">스레드 안전성 수준</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-83-%ec%a7%80%ec%97%b0-%ec%b4%88%ea%b8%b0%ed%99%94%eb%8a%94-%ec%8b%a0%ec%a4%91%ed%9e%88-%ec%82%ac%ec%9a%a9%ed%95%98%eb%9d%bc aria-label="아이템 83: 지연 초기화는 신중히 사용하라">아이템 83: 지연 초기화는 신중히 사용하라</a><ul><li><a href=#%eb%a9%80%ed%8b%b0%ec%8a%a4%eb%a0%88%eb%93%9c-%ed%99%98%ea%b2%bd%ec%97%90%ec%84%9c%ec%9d%98-%ec%a7%80%ec%97%b0-%ec%b4%88%ea%b8%b0%ed%99%94 aria-label="멀티스레드 환경에서의 지연 초기화">멀티스레드 환경에서의 지연 초기화</a></li></ul></li><li><a href=#%ec%95%84%ec%9d%b4%ed%85%9c-84-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%98-%eb%8f%99%ec%9e%91%ec%9d%84-%ec%8a%a4%eb%a0%88%eb%93%9c-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%9f%ac%ec%97%90-%ea%b8%b0%eb%8c%80%ec%a7%80-%eb%a7%90%eb%9d%bc aria-label="아이템 84: 프로그램의 동작을 스레드 스케줄러에 기대지 말라">아이템 84: 프로그램의 동작을 스레드 스케줄러에 기대지 말라</a></li></ul></div></details></div><div class=post-content><h2 id=아이템-78-공유-중인-가변-데이터는-동기화해-사용하라>아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-78-공유-중인-가변-데이터는-동기화해-사용하라>#</a></h2><p>여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopThread</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Thread backgroundThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>stopRequested<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>        backgroundThread<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit<span style=color:#f92672>.</span><span style=color:#a6e22e>SECONDS</span><span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다.</li><li>컴파일러 최적화 수행 결과 의도하지 않은 대로 동작할 수도 있다.</li></ul><h3 id=멀티-스레드-환경에서-가변-공유-데이터를-다루는-방법>멀티 스레드 환경에서 가변 공유 데이터를 다루는 방법<a hidden class=anchor aria-hidden=true href=#멀티-스레드-환경에서-가변-공유-데이터를-다루는-방법>#</a></h3><ul><li>멀티스레드에서 가변 데이터를 공유하지 말자. (최선)</li></ul><p>→ <code>synchronized</code> 를 사용해 동기화하자.</p><p>동기화 시에는 <strong>읽기와 쓰기 모두</strong>를 동기화해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>requestStop</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>stopRequested</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> stopRequested<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>→ <code>volatile</code> 을 사용하면 항상 가장 최근에 기록된 값을 읽도록 보증한다. (메모리 접근)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>boolean</span> stopRequested<span style=color:#f92672>;</span>
</span></span></code></pre></div><ul><li>하지만 원자적이지 않은 연산 수행 시에는 동기화해야 하며, 하지 않을 경우 <strong>안전 실패</strong>가 발생할 가능성이 있다.</li></ul><p>→ java.util.concurrent에서 제공하는 Atomic* 자료구조를 사용하면, 동기화 락 없이도 스레드 안전하게 구현이 가능하다.</p><h2 id=아이템-79-과도한-동기화는-피하라>아이템 79: 과도한 동기화는 피하라<a hidden class=anchor aria-hidden=true href=#아이템-79-과도한-동기화는-피하라>#</a></h2><p>너무 과한 동기화는 성능을 떨어뜨리고 데드락을 유발하거나, 안전 실패의 원인이 된다.</p><ul><li><p>응답 불가나 안전 실패를 피하려면 동기화 메서드나 동기화 블럭 안에서는 제어를 클라이언트에 양도해서는 안된다.</p><ul><li><p>외계인(?) 메서드</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 79-1 잘못된 코드. 동기화 블록 안에서 외계인 메서드를 호출한다. (420쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;&gt;</span> observers
</span></span><span style=display:flex><span>        <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addObserver</span><span style=color:#f92672>(</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>observers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        observers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>removeObserver</span><span style=color:#f92672>(</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>observers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> observers<span style=color:#f92672>.</span><span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span>observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notifyElementAdded</span><span style=color:#f92672>(</span>E element<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>observers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> observer <span style=color:#f92672>:</span> observers<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            observer<span style=color:#f92672>.</span><span style=color:#a6e22e>added</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> element<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test2</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ObservableSet<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> set <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ObservableSet<span style=color:#f92672>&lt;&gt;(</span><span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;&gt;());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        set<span style=color:#f92672>.</span><span style=color:#a6e22e>addObserver</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> SetObserver<span style=color:#f92672>&lt;&gt;()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>added</span><span style=color:#f92672>(</span>ObservableSet<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> s<span style=color:#f92672>,</span> Integer e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e <span style=color:#f92672>==</span> <span style=color:#ae81ff>23</span><span style=color:#f92672>)</span> <span style=color:#75715e>// 값이 23이면 자신을 구독해지한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    s<span style=color:#f92672>.</span><span style=color:#a6e22e>removeObserver</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>100</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span>
</span></span><span style=display:flex><span>            set<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>테스트 실행 시 ConcurrentModificationException 발생!</p><p>→ 동기화 블럭 안에서 클라이언트 메서드가 호출되었기 때문에 synchronized의 보호를 받지 못한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 79-3 외계인 메서드를 동기화 블록 바깥으로 옮겼다. - 열린 호출 (424쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notifyElementAdded</span><span style=color:#f92672>(</span>E element<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;&gt;</span> snapshot <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span>observers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        snapshot <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;(</span>observers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> observer <span style=color:#f92672>:</span> snapshot<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        observer<span style=color:#f92672>.</span><span style=color:#a6e22e>added</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> element<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 79-4 CopyOnWriteArrayList를 사용해 구현한 스레드 안전하고 관찰 가능한 집합 (425쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;&gt;</span> observers <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> CopyOnWriteArrayList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addObserver</span><span style=color:#f92672>(</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        observers<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>removeObserver</span><span style=color:#f92672>(</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> observer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> observers<span style=color:#f92672>.</span><span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span>observer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notifyElementAdded</span><span style=color:#f92672>(</span>E element<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>SetObserver<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> observer <span style=color:#f92672>:</span> observers<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            observer<span style=color:#f92672>.</span><span style=color:#a6e22e>added</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> element<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>E element<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> added <span style=color:#f92672>=</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>element<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>added<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            notifyElementAdded<span style=color:#f92672>(</span>element<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> added<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> E<span style=color:#f92672>&gt;</span> c<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>E element <span style=color:#f92672>:</span> c<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            result <span style=color:#f92672>|=</span> add<span style=color:#f92672>(</span>element<span style=color:#f92672>);</span>  <span style=color:#75715e>// notifyElementAdded를 호출한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div></li></ul></li><li><p>동기화 영역은 최대한 작게 가져가자.</p></li><li><p>합당한 이유가 있을 때만 내부에서 동기화하고, 동기화 여부를 문서에 명확히 밝히자.</p></li></ul><h2 id=아이템-80-스레드보다는-실행자-태스크-스트림을-애용하라>아이템 80: 스레드보다는 실행자, 태스크, 스트림을 애용하라<a hidden class=anchor aria-hidden=true href=#아이템-80-스레드보다는-실행자-태스크-스트림을-애용하라>#</a></h2><p>작업 큐를 만들기 위해 스레드를 직접 다루기보다는 java.util.concurrent 하위의 실행자 프레임워크를 이용하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ExecutorService exec <span style=color:#f92672>=</span> Executors<span style=color:#f92672>.</span><span style=color:#a6e22e>newSingleThreadExecutor</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>exec<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>runnable<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>exec<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdown</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><h3 id=실행자-프레임워크의-기능>실행자 프레임워크의 기능<a hidden class=anchor aria-hidden=true href=#실행자-프레임워크의-기능>#</a></h3><ul><li>특정 태스크 완료 대기</li><li>태스크 모음 중 아무거나 하나, 혹은 모든 태스크 완료 대기</li><li>실행자 서비스 종료 대기</li><li>완료된 태스크의 결과를 차례로 받기</li><li>태스크를 특정 시간, 혹은 주기로 실행하기</li></ul><p>프로그램 규모에 따라 각각 다른 스레드 관리 메커니즘을 사용하는 실행자 서비스를 생성할 수 있다.</p><p>ex) Executors.newCachedThreadPool, Executors.newFixedThreadPool, &mldr;</p><p>자바 7부터는 ForkJoinPool을 지원하도록 개량되어서 효율성이 개선되었다.</p><h2 id=아이템-81-wait과-notify보다는-동시성-유틸리티를-애용하라>아이템 81: wait과 notify보다는 동시성 유틸리티를 애용하라<a hidden class=anchor aria-hidden=true href=#아이템-81-wait과-notify보다는-동시성-유틸리티를-애용하라>#</a></h2><p>wait과 notify는 올바르게 사용하기 매우 어려우므로, 고수준 동시성 유틸리티를 사용하는 것이 좋다.</p><h3 id=고수준-동시성-유틸리티의-종류>고수준 동시성 유틸리티의 종류<a hidden class=anchor aria-hidden=true href=#고수준-동시성-유틸리티의-종류>#</a></h3><ul><li>실행자 프레임워크</li><li>동시성 컬렉션<ul><li>ConcurrentHashMap 등 내부에서 동기화를 효율적으로 구현한 컬렉션</li><li>상태 의존적 메서드들이 추가되어 있음 ex) putIfAbsent</li></ul></li><li>동기화 장치<ul><li>CountDownLatch, Semaphore, &mldr;</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 81-3 동시 실행 시간을 재는 간단한 프레임워크 (433-434쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConcurrentTimer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>ConcurrentTimer</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#f92672>}</span> <span style=color:#75715e>// 인스턴스 생성 불가
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>time</span><span style=color:#f92672>(</span>Executor executor<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> concurrency<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                            Runnable action<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        CountDownLatch ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch<span style=color:#f92672>(</span>concurrency<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        CountDownLatch start <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch<span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        CountDownLatch done  <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch<span style=color:#f92672>(</span>concurrency<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> concurrency<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            executor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                ready<span style=color:#f92672>.</span><span style=color:#a6e22e>countDown</span><span style=color:#f92672>();</span> <span style=color:#75715e>// 타이머에게 준비를 마쳤음을 알린다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    start<span style=color:#f92672>.</span><span style=color:#a6e22e>await</span><span style=color:#f92672>();</span> <span style=color:#75715e>// 모든 작업자 스레드가 준비될 때까지 기다린다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    action<span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>interrupt</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    done<span style=color:#f92672>.</span><span style=color:#a6e22e>countDown</span><span style=color:#f92672>();</span>  <span style=color:#75715e>// 타이머에게 작업을 마쳤음을 알린다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ready<span style=color:#f92672>.</span><span style=color:#a6e22e>await</span><span style=color:#f92672>();</span>     <span style=color:#75715e>// 모든 작업자가 준비될 때까지 기다린다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>long</span> startNanos <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        start<span style=color:#f92672>.</span><span style=color:#a6e22e>countDown</span><span style=color:#f92672>();</span> <span style=color:#75715e>// 작업자들을 깨운다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        done<span style=color:#f92672>.</span><span style=color:#a6e22e>await</span><span style=color:#f92672>();</span>      <span style=color:#75715e>// 모든 작업자가 일을 끝마치기를 기다린다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> startNanos<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>어쩔 수 없이 wait/notify를 사용해야 할 때에는 wait 호출 시 while 문 안에서만 호출하는 표준 방식을 따르자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>(&lt;</span><span style=color:#960050;background-color:#1e0010>조건이</span> <span style=color:#960050;background-color:#1e0010>충족되지</span> <span style=color:#960050;background-color:#1e0010>않았다</span><span style=color:#f92672>&gt;)</span>
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>.</span><span style=color:#a6e22e>wait</span><span style=color:#f92672>();</span> <span style=color:#75715e>// (락을 놓고, 깨어나면 다시 잡는다.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>...</span> <span style=color:#75715e>// 조건이 충족됐을 때의 동작을 수행한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=아이템-82-스레드-안전성-수준을-문서화하라>아이템 82: 스레드 안전성 수준을 문서화하라<a hidden class=anchor aria-hidden=true href=#아이템-82-스레드-안전성-수준을-문서화하라>#</a></h2><p>멀티스레드 환경에서 API를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 명시해야 한다.\</p><h3 id=스레드-안전성-수준>스레드 안전성 수준<a hidden class=anchor aria-hidden=true href=#스레드-안전성-수준>#</a></h3><ul><li>불변</li><li>무조건적 스레드 안전: 수정될 수 있으나 내부에서 동기화해서 별도의 처리 없이 스레드 안전하게 사용 가능하다.</li><li>조건부 스레드 안전: 일부 스레드를 사용하려면 외부 동기화가 필요하다.</li><li>스레드 안전하지 않음: 동시에 사용하기 위해서는 외부 동기화가 필요하다.</li><li>스레드 적대적: 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다. (정적 데이터를 동기화 없이 수정하는 경우)</li></ul><p>조건부 스레드 안전한 클래스는 주의해서 어떤 순서로 호출할 때 동기화 로직이 필요한지, 어떤 락을 얻어야 하는지 기술해야 한다.</p><p>공개된 락을 사용하는 경우 클라이언트에서 락을 풀지 않는 서비스 거부 공격을 할 수 있기 때문에, 비공개 락 객체를 사용하고 final로 선언하는 것이 좋다.</p><h2 id=아이템-83-지연-초기화는-신중히-사용하라>아이템 83: 지연 초기화는 신중히 사용하라<a hidden class=anchor aria-hidden=true href=#아이템-83-지연-초기화는-신중히-사용하라>#</a></h2><p>상황에 따라 지연 초기화는 오히려 성능을 더 느리게 만들 수 있으므로 신중히 사용해야 한다.</p><p>대부분의 상황에서는 일반적인 초기화가 좋다.</p><h3 id=멀티스레드-환경에서의-지연-초기화>멀티스레드 환경에서의 지연 초기화<a hidden class=anchor aria-hidden=true href=#멀티스레드-환경에서의-지연-초기화>#</a></h3><ul><li><p>지연 초기화가 초기화 순환성을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 83-2 인스턴스 필드의 지연 초기화 - synchronized 접근자 방식 (443쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> FieldType field2<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>synchronized</span> FieldType <span style=color:#a6e22e>getField2</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>field2 <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            field2 <span style=color:#f92672>=</span> computeFieldValue<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> field2<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div></li><li><p>성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 83-3 정적 필드용 지연 초기화 홀더 클래스 관용구 (443쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FieldHolder</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> FieldType field <span style=color:#f92672>=</span> computeFieldValue<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> FieldType <span style=color:#a6e22e>getField</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> FieldHolder<span style=color:#f92672>.</span><span style=color:#a6e22e>field</span><span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
</span></span></code></pre></div></li><li><p>성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중 검사 관용구를 사용하자.</p><p>→ 이미 초기화된 경우 synchronized 블럭에 진입하지 않아서 접근 비용이 작아진다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 83-4 인스턴스 필드 지연 초기화용 이중검사 관용구 (444쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> FieldType field4<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> FieldType <span style=color:#a6e22e>getField4</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        FieldType result <span style=color:#f92672>=</span> field4<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>    <span style=color:#75715e>// 첫 번째 검사 (락 사용 안 함)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>field4 <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#75715e>// 두 번째 검사 (락 사용)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                field4 <span style=color:#f92672>=</span> computeFieldValue<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> field4<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div></li><li><p>반복해서 초기화해도 상관없는 경우 동기화 없이 단일 검사해도 괜찮다.</p></li></ul><h2 id=아이템-84-프로그램의-동작을-스레드-스케줄러에-기대지-말라>아이템 84: 프로그램의 동작을 스레드 스케줄러에 기대지 말라<a hidden class=anchor aria-hidden=true href=#아이템-84-프로그램의-동작을-스레드-스케줄러에-기대지-말라>#</a></h2><p>스레드 스케줄러의 동작은 플랫폼, 운영체제마다 다르기 때문에 다른 플랫폼에 이식하기 어려워질 수 있다.</p><ul><li><p>실행 가능한 스레드의 수가 프로세스의 수보다 과도하게 많아서는 안 된다.</p></li><li><p>스레드는 당장 처리해야 할 작업이 없다면 실행되어서는 안 된다.</p></li><li><p>스레드는 절대 바쁜 대기 상태가 되어서는 안 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 코드 84-1 끔찍한 CountDownLatch 구현 - 바쁜 대기 버전! (447쪽)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SlowCountDownLatch</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SlowCountDownLatch</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> count<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException<span style=color:#f92672>(</span>count <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &lt; 0&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>count</span> <span style=color:#f92672>=</span> count<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>await</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>countDown</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>count <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            count<span style=color:#f92672>--;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>→ 이 문제를 고친답시고 Thread.yield 등을 사용한다면 JVM 구현체별로 다른 효과에 이식성만 나빠지는 결과를 초래할 수 있다.</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://junbread.win/tags/study/>Study</a></li><li><a href=https://junbread.win/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://junbread.win/posts/2021/effective-java-10/><span class=title>« Prev</span><br><span>이펙티브 자바 10장 정리</span></a>
<a class=next href=https://junbread.win/posts/2021/effective-java-12/><span class=title>Next »</span><br><span>이펙티브 자바 12장 정리</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=junbread/blog data-repo-id=R_kgDOJLcBtQ data-category=Comments data-category-id=DIC_kwDOJLcBtc4CVATm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=dark data-lang=ko data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://junbread.win>Junbread🥐</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>