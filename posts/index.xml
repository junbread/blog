<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Junbread🥐</title><link>https://junbread.win/posts/</link><description>Recent content in Posts on Junbread🥐</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 16 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://junbread.win/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>이펙티브 자바 10장 정리</title><link>https://junbread.win/posts/2021/effective-java-10/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-10/</guid><description>아이템 69: 예외는 진짜 예외 상황에만 사용하라 예외는 오직 예외 상황에서만 쓰여야 하며, 일상적인 제어 흐름용으로 사용되어서는 안 된다.
예외 코드를 사용하면 JVM에서 최적화할 수 있는 여지가 적어진다.
try { int i = 0; while(true) range[i++].climb(); } catch (ArrayIndexOutOfBoundsException e) {} // don&amp;#39;t for (Mountain m : range) m.climb(); // do 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없어야 한다.
특정 상태에서만 호출할 수 있는 상태 의존적 메서드를 제공한다면, 상태 검사 메서드도 함께 제공해야 한다.</description></item><item><title>이펙티브 자바 11장 정리</title><link>https://junbread.win/posts/2021/effective-java-11/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-11/</guid><description>아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라 여러 스레드가 하나의 가변 데이터를 사용할 때에 입출력 시 동기화에 신경쓰지 않는다면 잘못된 동작을 유발할 수 있다.
// 코드 78-1 잘못된 코드 - 이 프로그램은 얼마나 오래 실행될까? (415쪽) public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -&amp;gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 여러 스레드가 공유하는 가변 데이터를 동기화하지 않을 경우 다른 스레드에서 변경한 값을 언제 보게 될 지 알 수 없다.</description></item><item><title>이펙티브 자바 12장 정리</title><link>https://junbread.win/posts/2021/effective-java-12/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-12/</guid><description>아이템 85: 자바 직렬화의 대안을 찾으라 자바 직렬화에는 공격의 소지가 매우 많고, 점점 더 많아지고 있기 때문에 가급적 사용하지 말아야 한다.
자바 직렬화를 사용하는 방법 아무것도 역직렬화하지 않는다.
레거시 등으로 어쩔 수 없이 사용하더라도, 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는다.
아이템 86: Serializable을 구현할지는 신중히 결정하라 Serializable 구현의 단점들 Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.
→ 직렬화 형태 또한 공개 API가 되기 때문
버그와 보안 구멍이 생길 가능성이 높아진다.</description></item><item><title>이펙티브 자바 8장 정리</title><link>https://junbread.win/posts/2021/effective-java-08/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-08/</guid><description>아이템 49: 매개변수가 유효한지 검사하라 메서드나 생성자를 작성할 때에는 매개변수에 어떤 제약이 있을지 생각해야 한다.
제약사항을 문서화하고 메서드 시작 부분에 명시적으로 검사하자. 유효성 검사를 제대로 하지 않는 경우에는 중간에 모호한 오류가 발생하거나, 잘못된 결과를 반환하거나, 실패 원자성이 깨지는 결과를 낳을 수 있다. public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. /** * (현재 값 mod m) 값을 반환한다. 이 메서드는 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.</description></item><item><title>이펙티브 자바 9장 정리</title><link>https://junbread.win/posts/2021/effective-java-09/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-09/</guid><description>아이템 57: 지역변수의 범위를 최소화하라 자바는 문장을 선언할 수 있는 곳이면 어디든 변수를 선언할 수 있기 때문에 가장 처음 쓰일 때 선언하는 것이 좋으며, 스코프가 오염되는 것을 방지할 수 있다.
지역변수 초기화 시점 거의 모든 지역변수는 선언과 동시에 초기화해야 한다. 예외적으로 try-catch를 사용할 때는 try 블록 안에서 초기화해야 한다. 반복문은 while 문보다는 for 문을 사용하자 → while 문을 사용할 때는 반복문 블록 밖에 불필요한 변수가 존재하기 때문에 잠재적인 오류 가능성이 있다.</description></item><item><title>이펙티브 자바 7장 정리</title><link>https://junbread.win/posts/2021/effective-java-07/</link><pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-07/</guid><description>아이템 42: 익명 클래스보다는 람다를 사용하라 예전에는 함수 타입을 표현할 때 추상 메서드가 하나만 있는 인터페이스를 익명 클래스로 구현하는 방식을 사용했다.
Collections.sort(words, new Comparator&amp;lt;String&amp;gt;() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); 람다가 도입되면서 간결한 방식으로 함수 객체를 표현할 수 있게 되었다.
Collections.sort(words, (s1, s2) -&amp;gt; Integer.compare(s1.length(), s2.length())); // 코드 42-4 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입 (256-257쪽) public enum Operation { PLUS (&amp;#34;+&amp;#34;, (x, y) -&amp;gt; x + y), MINUS (&amp;#34;-&amp;#34;, (x, y) -&amp;gt; x - y), TIMES (&amp;#34;*&amp;#34;, (x, y) -&amp;gt; x * y), DIVIDE(&amp;#34;/&amp;#34;, (x, y) -&amp;gt; x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) { this.</description></item><item><title>이펙티브 자바 6장 정리</title><link>https://junbread.win/posts/2021/effective-java-06/</link><pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-06/</guid><description>아이템 34: int 상수 대신 열거 타입을 사용하라 Java 1.5 Enum 등장 전 사용되던 int enum 패턴
public static final int APPLE_FUJI = 0; public static final int APPLE_PIPPIN = 1; public static final int APPLE_GRANNY_SMITH = 2; public static final int ORANGE_NAVEL = 0; public static final int ORANGE_TEMPLE = 1; public static final int ORANGE_BLOOD = 2; 타입 안전을 보장할 방법이 없다. 표현 방식이 까다롭다. toString(), 디버거 등에서는 그냥 아무 의미 없는 상수로 보인다.</description></item><item><title>이펙티브 자바 5장 정리</title><link>https://junbread.win/posts/2021/effective-java-05/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-05/</guid><description>제네릭은 취급할 수 있는 타입을 컴파일러에게 알려줌으로써, 컴파일 타임에 올바른 타입을 사용했는지 검사할 수 있게 해 더 안전하고 명확한 프로그램을 만들 수 있게 한다.
아이템 26: 로 타입은 사용하지 말라 로 타입이란 제네릭에서 타입 매개변수를 전혀 사용하지 않은 경우를 말한다.
→ 컴파일 타임 오류 검사를 사용할 수 없기 때문에 제네릭의 안전성과 표현력을 전혀 활용할 수 없다.
public class Raw { public static void main(String[] args) { List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;(); unsafeAdd(strings, Integer.</description></item><item><title>이펙티브 자바 4장 정리</title><link>https://junbread.win/posts/2021/effective-java-04/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-04/</guid><description>아이템 15: 클래스와 멤버의 접근 권한을 최소화하라 정보 은닉은 시스템을 구성하는 컴포넌트를 서로 독립시켜 준다.
정보 은닉의 장점 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있다. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하고, 교체하는 데 부담이 줄어든다. 성능 최적화에 도움을 준다. 각 컴포넌트가 독립되어 있기 때문에 특정 컴포넌트만 최적화가 가능하다. 소프트웨어 재사용성을 높인다. 외부 의존 없이 동작하는 컴포넌트는 다른 환경에서도 사용이 쉽다. 대형 시스템 제작 난이도를 낮춘다.</description></item><item><title>이펙티브 자바 3장 정리</title><link>https://junbread.win/posts/2021/effective-java-03/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/effective-java-03/</guid><description>아이템 10: equals는 일반 규약을 지켜 재정의하라 equals는 언제 재정의해야 할까? 클래스가 다음과 같은 상황에 있다면 재정의하지 않는 것이 좋다.
각 인스턴스가 본질적으로 고유하다 인스턴스의 논리적 동치성을 검사할 일이 없다 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다 equals가 만족시켜야 하는 조건 equals는 다음 다섯 가지 조건을 만족해야 한다.
반사성: A.equals(A)가 참이다
대칭성: A.equals(B)가 참이라면 B.equals(A)이다
public class Point { @Override boolean equals(Object o) { if (!</description></item><item><title>Bash</title><link>https://junbread.win/posts/2021/bash/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/bash/</guid><description>가장 널리 쓰이는 리눅스 셸. 많은 배포판에서 기본 셸로 지정되어 있다. fish와 zsh도 사용해 봤지만, 가볍고 범용적인 bash로 결국 돌아오게 된다.
Cheetsheet 직접적으로 Bash와 관련 없지만 터미널 전반적인 명령어 사용법도 함께 수록한다.
cd -: 직전 히스토리로 돌아가기 !!: 직전 사용 명령어. sudo !! 식으로 사용하면 깜빡하고 sudo를 붙이지 않은 명령어를 다시 입력할 필요가 없다. 사용 노하우 여러 환경에서 일관되게 .bashrc 관리하기 ~/.bashrc는 여러 가지 bash 설정을 기입해 놓은 파일이다. 다른 설정을 수정하지 않았을 경우 여기서 설정을 로드한다.</description></item><item><title>Chrome 확장기능 추천목록</title><link>https://junbread.win/posts/2021/chrome-extension-recommendation/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/chrome-extension-recommendation/</guid><description>IPA furigana 웹페이지에 있는 한자 단어에 후리가나를 달아 주는 확장
Vimium vim-like 키매핑으로 웹서핑을 가능하게 해 주는 확장
f 키가 꿀 기능이다.
Quick QR Code Generator 보고 있는 페이지 URL을 QR 코드로 만들어 주는 확장
Windows-iOS 간 히스토리 공유가 안 되어서.. PC에서 보던거 폰으로 옮기고 싶을 때 가끔 사용
최신 버전 크로미움의 경우 브라우저에서 자체적으로 이 기능을 지원해 주기 시작한 것 같다.
이 링크에서 활성화 가능</description></item><item><title>VS Code</title><link>https://junbread.win/posts/2021/vs-code/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/vs-code/</guid><description>마이크로소프트에서 개발한 강력한 텍스트 에디터. Electron 기반으로 만들어졌다.
사용하고 있는 플러그인 Shell launcher VS Code에 임베드되어 있는 터미널 패널은 기본 셸 환경을 바꿀 수 있도록 되어 있지만, 상황별로 다른 셸을 사용하고자 할 때는 불편하다. Shell launcher 플러그인은 현재 설치되어 있는 셸을 자동으로 인식해 리스트에 표시해 준다. 간단하지만 편리하다.
Render Line Endings Windows 머신에 WSL을 설치해 사용하고 있다. 한 가지 문제는 Windows와 Linux의 EOL 처리가 서로 달라서 충돌이 일어나는 경우가 있다는 것이다.</description></item><item><title>Windows 유틸리티 추천목록</title><link>https://junbread.win/posts/2021/windows-utility-recommendation/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/windows-utility-recommendation/</guid><description>Windows 환경에서 유용하게 사용할 수 있는 유틸리티 모음
LittleBigMouse 멀티 모니터 마우스 스케일링 유틸리티
멀티 모니터 사용 시 DPI 차이에 따른 마우스 위치 어긋남 등을 조정해 주는 유틸리티
DPI 스케일링뿐만 아니라 모니터 위치 정밀 조정 등 여러가지 편리한 기능이 들어가 있다
mgth/LittleBigMouse
Chocolatey Windows 커맨드라인 패키지 매니저
brew, apt 등과 같은 기능을 제공한다. 웬만한 패키지는 다 있음
비슷한 걸로 scoop, winget 등이 있는데, scoop은 유저스페이스에만 설치가 가능하고 winget은 아직 개발중이라 별로</description></item><item><title>WSL</title><link>https://junbread.win/posts/2021/wsl/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://junbread.win/posts/2021/wsl/</guid><description>Windows Subsystem for Linux
개요 Windows에서 리눅스를 구동할 수 있게 해 준다. WSL 1은 리눅스 시스템 콜을 Windows 시스템 콜로 번역하는 식으로 이루어졌지만 WSL 2부터는 Hyper-V를 이용해 구동된다.
설치 WSL 1의 경우 Windows 10 Pro 에디션 이상이 필요하다. WSL 2부터는 Windows 10 Home 에디션에서도 이용할 수 있게 되었다.
Microsoft Docs에 자세한 설치 과정이 안내되어 있다.
팁과 주의사항 Hyper-V 사용시 퍼포먼스 하락 WSL 2는 Hyper-V를 사용하기 때문에 설치 전 Hyper-V 기능을 사용 설정해야 한다.</description></item></channel></rss>